

  
<!DOCTYPE html>

<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>7. Struktura terminowa stóp procentowych &#8212; Analiza Rynków Finansowych</title>
    <link rel="stylesheet" href="_static/upgow.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono&amp;subset=latin,latin-ext" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/jquery.cookie.js"></script>
    <script src="_static/cloud.js"></script>
    <script type="text/javascript" src="https://sagecell.sagemath.org/static/jquery.min.js"></script>
    <script type="text/javascript" src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <script type="text/javascript">
        sagecell.makeSagecell({inputLocation: ".sage_linked",
                               linked: true,
                       	evalButtonText: 'Wykonaj'});
        sagecell.makeSagecell({inputLocation: ".sage_unlinked",
                               linked: false,
                           evalButtonText: 'Wykonaj'});
    </script>

    <style type="text/css">
        .sagecell .CodeMirror-scroll {
            overflow-y: hidden;
            overflow-x: auto;
        }
        .sagecell .CodeMirror {
            height: auto;
        }
    </style>
    
    <link rel="index" title="Indeks" href="genindex.html" />
    <link rel="search" title="Szukaj" href="search.html" />
    <link rel="next" title="8. Pewne aspekty wymiany walut" href="forex.html" />
    <link rel="prev" title="6. Instrumenty stałego dochodu" href="instrumenty_stalego_dochodu.html" />
 
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
  </head><body>
  <div class="relbar-top">
    
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Nawigacja</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Indeks ogólny"
             accesskey="I">indeks</a></li>
        <li class="right" >
          <a href="forex.html" title="8. Pewne aspekty wymiany walut"
             accesskey="N">dalej</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="instrumenty_stalego_dochodu.html" title="6. Instrumenty stałego dochodu"
             accesskey="P">wstecz</a> &nbsp; &nbsp;</li>
  <li><a href="index.html">Analiza Rynków Finansowych</a> &#187;</li>
  
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7. </span>Struktura  terminowa stóp procentowych</a></li> 
      </ul>
    </div>
  </div>
  
  <div class="content">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="struktura-terminowa-stop-procentowych">
<h1><span class="section-number">7. </span>Struktura  terminowa stóp procentowych<a class="headerlink" href="#struktura-terminowa-stop-procentowych" title="Stały odnośnik do tego nagłówka">¶</a></h1>
<div class="section" id="podstawowe-zaleznosci">
<h2><span class="section-number">7.1. </span>Podstawowe zależności<a class="headerlink" href="#podstawowe-zaleznosci" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Jeśli mamy do czynienie z instrumentem dłużnym generującym określoną
stopę zwrotu w określonym czasie. Ponadto, jeśli inwestujemy kwotę
inwestycji na końcu każdego etapu na okres następny, w którym stopa
procentowa może być inna albo taka sama to mamy do czynienia z
inwestycją wieloetapową.</p>
<p>Jeśli zdefiniujemy zwrot z inwestycji jako:</p>
<div class="math notranslate nohighlight" id="equation-zwrotr">
<span class="eqno">(1)<a class="headerlink" href="#equation-zwrotr" title="Stały odnośnik do tego równania">¶</a></span>\[R = \frac{S - S_0}{S_0},\]</div>
<p>gdzie: <span class="math notranslate nohighlight">\(S\)</span> końcowa wartość naszego portfela a <span class="math notranslate nohighlight">\(S_0\)</span> to
jego wartość początkowa.</p>
<p>Jeśli w portfelu mamy instrument dłużny (instrument stałego dochodu) o
stopie procentowej w danym okresie <span class="math notranslate nohighlight">\(i\)</span> równej <span class="math notranslate nohighlight">\(r_i\)</span>, to
licząc wartości portfela w kolejnych etapach inwestowania otrzymujemy:</p>
<div class="math notranslate nohighlight">
\begin{alignat*}{4}
  S_1  = &amp;\; S_0 (1+ r_1)  \\
  S_2 = &amp;\; S_1 (1+ r_2) = S_0 (1+ r_1) (1+ r_2) \\
  S_3 = &amp;\; S_2 (1+ r_3) = S_0 (1+ r_1) (1+ r_2) (1+ r_3)\\
  \dots\quad\ &amp;  \\
  S_n = &amp;\; S_{n-1} (1 + r_n) = S_0 (1 + r_1) (1+ r_2) (1+ r_3)\cdots (1+ r_n)
\end{alignat*}</div><p>Korzystając ze wzoru definiującego <a class="reference internal" href="#equation-zwrotr">(1)</a> widać, że zwrot z takiej
wieloetapowej inwestycji wynosi:</p>
<div class="math notranslate nohighlight" id="equation-zwrotrn">
<span class="eqno">(2)<a class="headerlink" href="#equation-zwrotrn" title="Stały odnośnik do tego równania">¶</a></span>\[R = \prod_{i=1}^n (1+ r_i) - 1\]</div>
<p>Stopa średnia roczna to wielkość stopy, która stosowana do każdego
roku inwestycji da końcowy wynik równy <span class="math notranslate nohighlight">\(R\)</span>. Czyli:</p>
<div class="math notranslate nohighlight" id="equation-srednia-roczna-pre">
<span class="eqno">(3)<a class="headerlink" href="#equation-srednia-roczna-pre" title="Stały odnośnik do tego równania">¶</a></span>\[(r_s+1)^n  = \prod_{i=1}^n (1+ r_i)\]</div>
<p>Stąd wynika wzór:</p>
<div class="math notranslate nohighlight" id="equation-srednia-roczna">
<span class="eqno">(4)<a class="headerlink" href="#equation-srednia-roczna" title="Stały odnośnik do tego równania">¶</a></span>\[r_s = \sqrt[n]{\prod_{i=1}^n (1+ r_i)} - 1\]</div>
<p>Inaczej <span class="math notranslate nohighlight">\(r_s\)</span> nosi nazwę średniej geometrycznej stopy zwrotu</p>
<p>Przypominamy, że w finansach występuje wiele rodzajów
„średnich”. Należy zawsze pamiętać jak się je liczy i wiedzieć, że nie
są to raczej średnie arytmetyczne. Średnia arytmetyczna w przypadku
wieloetapowej inwestycji w instrument stałego dochodu była by średnią
arytmetyczną gdyby w każdym etapie inwestowana była ta sama wartość
portfela. Dla takich samych <span class="math notranslate nohighlight">\(r_i\)</span> i  takich samych <span class="math notranslate nohighlight">\(i\)</span>
średnia geometryczna stopa zwrotu jest zawsze mniejsza lub równa średniej arytmetycznej stopie zwrotu.</p>
</div>
<div class="section" id="krzywa-dochodowosci">
<h2><span class="section-number">7.2. </span>Krzywa dochodowości<a class="headerlink" href="#krzywa-dochodowosci" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Związek miedzy dochodowościami obligacji a czasem ich życia określa
krzywa zwana krzywą dochodowości. Konstrukcja krzywej dochodowości
jest tylko łatwa jeśli dysponujemy jednorodnymi obligacjami o różnych
datach zapadalności pozwalających na konstrukcje tejże
krzywej.  Ten zbiór danych powinien zawierać wszystkie kolejne daty
zapadalności.  Największy problem to właśnie założenie istnienia jednorodnego
zbioru obligacji o różnej zapadalności. Obligacje raczej nie są
jednorodne czyli mogą charakteryzować się nie tym samym ryzykiem
i nie musi charakteryzować ich dużą i taka sama płynność.  Z tych przykładowo
powodów strukturę terminowa stóp procentowych określa się na podstawie
krzywej dochodowości dla wybranych obligacji, przykładowo o tym samym
oprocentowaniu, czy też biorąc pod uwagę stopę zwrotu do zapadalności.</p>
<div class="figure align-center" id="id1" style="width: 340px">
<a class="reference internal image-reference" href="_images/krzywa_dochodowosci.png"><img alt="_images/krzywa_dochodowosci.png" src="_images/krzywa_dochodowosci.png" style="height: 230px;" /></a>
<p class="caption"><span class="caption-text">Krzywa dochodowości</span><a class="headerlink" href="#id1" title="Stały odnośnik do tego obrazu">¶</a></p>
</div>
<p>Stopy spot to stopy oprocentowania pożyczek dzisiaj: rok, 2 lata,
5lat, 10 lat, etc…  Krzywa rentowności to pokazanie aktualnych stóp
spot dla różnych zapadalności.  Z kształtu krzywej rentowności
inwestorzy optymalizują swe działania inwestycyjne. Decydują czy
lepiej reinwestować środki na okresy krótsze czy dłuższe. Stopy spot to stopy realnie występujące na rynku.</p>
<p>Stopy forward to stopy, których okres odsetkowy rozpocznie sie w przyszłości.
Stopy forward sa implikowane przez instrumenty finansowe. Stopy forward można wyliczyć z wartości stóp spot.
Wyliczanie stop forward ilustrować może poniższy przykład.
Przykładowo, przyjmijmy hipotetycznie istniejące instrumenty dłużne,
które obserwujemy na hipotetycznym rynku.  Instrumenty te są
instrumentami emitowanymi przez Skarb Państwa (hipotetycznego) więc
możemy przyjąć, że są to instrumenty o minimalnym ryzyku na naszym
rynku i o ryzyku podobnym.  Przyjmijmy ponadto, że instrumenty te mają
wartość nominalna jednakową - powiedzmy 100 000.</p>
<p>Tak więc bierzemy pod uwagę:</p>
<ol class="arabic simple">
<li><p>Jednoroczny bon skarbowy sprzedawany na rynku po 86 956.</p></li>
<li><p>Skarbową obligację dwuletnią wypłacającą kupon 15.5% i handlowaną po 100060</p></li>
<li><p>Trzyletnią obligację skarbową o kuponie 16.2% handlowaną po 100680.</p></li>
</ol>
<p>Aby określić stopy forward postępuje się następująco. Z danych bonu
skarbowego wyliczamy stopę roczną:</p>
<div class="math notranslate nohighlight">
\[86956 = \frac{100 000}{1+r_1}\]</div>
<p>stąd <span class="math notranslate nohighlight">\(r_1 = 15\%\)</span>.</p>
<p>Z danych obligacji dwuletniej wyliczamy stopę roczną za drugi rok -
<span class="math notranslate nohighlight">\(r_2\)</span>:</p>
<div class="math notranslate nohighlight">
\[100060 = \frac{15500}{ 1 + r_1} + \frac{115500}{( 1+r_1)(1+r_2)}\]</div>
<p>stad <span class="math notranslate nohighlight">\(r_2 =16\%\)</span>.</p>
<p>Z danych obligacji trzyletniej otrzymujemy:</p>
<div class="math notranslate nohighlight">
\[100680 = \frac{16200}{1 + r_1} + \frac{16200}{ (1+r_1) (1+r_2)} + \frac{116200}{(1+r_1)(1+r_2)(1+r_3)}\]</div>
<p>Stad <span class="math notranslate nohighlight">\(r_3 = 17\%\)</span>.</p>
<p>Sprawdźmy te obliczenia wykorzystując Sage:</p>
<div class='sage_linked'><script type='text/x-sage'>var('r1,r2,r3')
s =solve( [86956  == 100000./(1+r1),\
     100060 == 15500/(1 + r1)+115500/((1+r1)*(1+r2)),\
     100680 == 16200/(1+r1)+16200/((1+r1)*(1+r2))+116200/((1+r1)*(1+r2)*(1+r3)) ] ,[r1,r2,r3] )

print( list( map(lambda x:x.rhs().n()*100,s[0])) )</script></div><p>Przy czym należy podkreślić, że <span class="math notranslate nohighlight">\(r_2\)</span> to stopa roczna dla roku
drugiego życia obligacji, a <span class="math notranslate nohighlight">\(r_3\)</span> to roczna stopa oprocentowania
„za dwa lata” na rok trzeci.</p>
<p>W przypadku stóp  forward użytecznym jest następujące oznaczenie:</p>
<p>Stopy forward to oprocentowanie dla pożyczki zawartej w przyszłości - <span class="math notranslate nohighlight">\(F\)</span>:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F(1,1)\)</span>  oprocentowanie rocznej pożyczki zawartej w terminie 1 rok od dziś</p></li>
<li><p><span class="math notranslate nohighlight">\(F(1,2)\)</span>  oprocentowanie 2 letniej pożyczki zawartej w  terminie rok od  dziś.</p></li>
<li><p><span class="math notranslate nohighlight">\(F(2,1)\)</span>  oprocentowanie jedno rocznej pożyczki zawartej w terminie 2 lat od dziś</p></li>
</ul>
</div></blockquote>
<p>Stopa spot  to szczególny przypadek - <span class="math notranslate nohighlight">\(S(1) = F(0,1)\)</span></p>
<p>Zasadę tę  ilustruje  rysunek poniżej:</p>
<div class="figure align-center" id="id2" style="width: 240px">
<a class="reference internal image-reference" href="_images/stopy_fwd_ML.png"><img alt="_images/stopy_fwd_ML.png" src="_images/stopy_fwd_ML.png" style="width: 220px;" /></a>
<p class="caption"><span class="caption-text">Zbiór stóp forward i związanych z nimi stóp „spot”.</span><a class="headerlink" href="#id2" title="Stały odnośnik do tego obrazu">¶</a></p>
</div>
<p>Przyjmijmy, że na rynku znajdujemy dwuletni bon skarbowy A o
rentowności rocznej 3.52% a bon roczny B, ma roczną rentowność równa
3.12%. Aby określić stopę forward <span class="math notranslate nohighlight">\(F(1,1)\)</span>, widzimy że
inwestując w bon A jednostkę pieniędzy otrzymujemy:</p>
<div class="math notranslate nohighlight">
\[\text{Bon A: }\; ( 1 + 0.0352)( 1 + 0.0352)= 1.0716\]</div>
<p>Czyli ok. 7.2% zwrotu. Inwestując natomiast w bon B na rok jednostkę
pieniędzy inwestujemy ja na 3.15% ale możemy otrzymany wynik
reinwestować na kolejny rok na stopę <span class="math notranslate nohighlight">\(F(1.1)\)</span>. Zakładając, że
na rynku nie istnieje możliwość arbitrażu, to obie te strategie muszą
dać ten sam efekt inwestycji. Czyli:</p>
<div class="math notranslate nohighlight">
\[(1+ 0.0312) ( 1+ F(1.1)) = ( 1 +0.0352)( 1 + 0.0352)\]</div>
<p>Stąd:</p>
<div class="math notranslate nohighlight">
\[( 1 + F(1.1,) )= ( 1 + 0.0352)( 1 + 0.0352)/1.0312 = 1.0392\]</div>
<p>Czyli <span class="math notranslate nohighlight">\(F(1.1)\)</span> musi wynosić 3.92 % rocznie.</p>
<p>Można postąpić również odwrotnie. Znając zestaw stóp forward możemy
wyliczyć stopy spot.  Załóżmy, że stopa <span class="math notranslate nohighlight">\(F(0.1)\)</span> wynosi 2.5% a
<span class="math notranslate nohighlight">\(F(1.1)\)</span>) wynosi 3.2%. Należy wyliczyć <span class="math notranslate nohighlight">\(S(2)\)</span>.
Postępujemy tak jak poprzednio i porównujemy do siebie dwie możliwe
strategie inwestycyjne.  Inwestujemy jednostkę pieniężną albo:</p>
<ol class="arabic">
<li><p>Na  dwa lata przy stopie  <span class="math notranslate nohighlight">\(S(2)\)</span>, co daje:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[(1+ S(2))( 1+ S(2))= (1+ S(2))^2\]</div>
</div></blockquote>
</li>
<li><p>Inwestujemy jednostkę pieniężną na pierwszy rok przy stopie
<span class="math notranslate nohighlight">\(F(0.1)\)</span> a następnie efekt inwestycji reinwestujemy na
kolejny rok przy stopie <span class="math notranslate nohighlight">\(F(1.1)\)</span> czyli:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[(1+ 0.02)(1+ 0.032)=1.05264\]</div>
<p>około 5.27% a to powinno być równe inwestycji 1.</p>
</div></blockquote>
</li>
</ol>
<p>Innymi słowy:</p>
<div class="math notranslate nohighlight">
\[(1+ S(2))^22 = (1+ 0.02)(1+ 0.032).\]</div>
<p>Stąd</p>
<div class="math notranslate nohighlight">
\[(1+S(2)) = \frac{1}{2}[(1+ 0.02)(1+0.032)]= 1.027\]</div>
<p>czyli <span class="math notranslate nohighlight">\(S(2) = 2.7\%\)</span>.</p>
<p>W ostatnim przykładzie wyliczona stopa spot jest średnią geometryczną
stóp zwrotu forward.  Czego należało się spodziewać, mając na uwadze
wzór <a class="reference internal" href="#equation-srednia-roczna">(4)</a>.</p>
<p>Wiedząc, że:</p>
<div class="math notranslate nohighlight">
\[\sqrt[n]{a_1 a_2\dots a_n} \le \frac{1}{n}\sum_{i=1}^n a_i\]</div>
<p>Możemy używać średniej matematycznej do szacowania średniej
geometrycznej.</p>
</div>
<div class="section" id="modele-dyskretne-ewolucji-stop-procentowych">
<h2><span class="section-number">7.3. </span>Modele dyskretne ewolucji stóp procentowych<a class="headerlink" href="#modele-dyskretne-ewolucji-stop-procentowych" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Stopa forward to stopa terminowa czyli „pojawiająca” się za pewien
czas. Można interpretować ją jako ewolucje stopy spot. Gdyby nie
istniała niepewność na rynku co do scenariusza dalszego jego rozwoju
to stopa foward byłaby nielosowa i z góry znana. Jednakże istniejąca
niepewność przyszłości zmusza nas do ustawicznego modelowania ewolucji
stopy forward jako procesu stochastycznego.</p>
<p>Stopy forward pokazują ewolucje stóp na rynku. Więc należy tą ewolucje
śledzić mając na uwadze efektywne zarządzanie portfelem instrumentów
dłużnych. Temu celowi służy tworzenie modelu aby wyjaśnić ruch stóp
forward. Następnie wyliczamy krzywą rentowności wynikającą ze stóp
forward i porównujemy ją z krzywą stóp aktualnych.  Modelowanie polega
przykładowo na stworzeniu modelu dwumiennego (stopa zmieniać się może
okresowo poprzez wzrost lub zmalenie) albo modelu trójmiennego, gdy
wartośc stopy w kolejnym okresie czasu z określonym
prawdopodobieństwem zmienia się w górę lub w dół albo nie zmienia się
w ogóle.</p>
<p>Rozważając modele dwumienne, należy odróżnić dwa zasadnicze typy -
drzewa rekombinujące i nierekombinujące. Te pierwsze mają w każdym
kolejnym okresie dokładnie o jedną unikalną wartość stopy procentowej
więcej. Te drugie mają po każdym okresie dwa razy więcej wartości
stopy procentowej, co implikuje wzrost liczby stanów z liczbą okresów
jak <span class="math notranslate nohighlight">\(2^n\)</span>.</p>
<p id="przyklad-drzewa">Rozważmy przykład drzewa binarnego rekombinującego. Niech w chwili
<span class="math notranslate nohighlight">\(t=0\)</span> stopa procentowa wynosi <span class="math notranslate nohighlight">\(4\%\)</span>.  Czyli <span class="math notranslate nohighlight">\(F(0,1)
= S(1)\)</span>. Stopa może ewoluować w czasie i przyjmujęmy regułę, że z
prawdopodobieństwem <span class="math notranslate nohighlight">\(50\%\)</span> może wzrosnąć o <span class="math notranslate nohighlight">\(0.7\%\)</span> do
wartości <span class="math notranslate nohighlight">\(4.7\%\)</span> albo spaść o <span class="math notranslate nohighlight">\(0.2\%\)</span> do wartość
<span class="math notranslate nohighlight">\(3.8\%\)</span> z tym samym prawdopodobieństwem <span class="math notranslate nohighlight">\(50\%\)</span>.
Graficznie przedstawiamy to w następujący sposób:</p>
<div class="figure align-center" style="width: 340px">
<img alt="_images/tree1.png" src="_images/tree1.png" />
</div>
<p>Mamy więc dwa scenariusze, nazywane tutaj ścieżkami:</p>
<dl class="simple">
<dt>Ścieżka 1,</dt><dd><p>w której stopa wzrasta ze skumulowanym zwrotem <span class="math notranslate nohighlight">\(1.04\times1.047 = 1.089\)</span></p>
</dd>
<dt>Ścieżka 2,</dt><dd><p>w której stopa maleje  ze skumulowanym zwrotem <span class="math notranslate nohighlight">\(1.04\times1.038 = 1.08\)</span>.</p>
</dd>
</dl>
<p>Skumulowany średni zwrot z dwu lat będzie średnią arytmetyczną z dwóch
powyższych scenariuszy i wynosi:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2} \text{Ścieżka 1} + \frac{1}{2} \text{Ścieżka 2} = \frac{1}{2} 1.09 + \frac{1}{2} 1.079 = 1.085\]</div>
<p>czyli <span class="math notranslate nohighlight">\(8.5\%.\)</span> Zanualizowany zwrot czyli <span class="math notranslate nohighlight">\(S(2)\)</span> jest równy:</p>
<div class="math notranslate nohighlight">
\[1.085\frac{1}{2} = 1.042\]</div>
<p>czyli <span class="math notranslate nohighlight">\(4.2\%\)</span>.</p>
<p>W kolejnym okresie mamy trzy stany i cztery różne scenariusze dojścia do nich:</p>
<div class="figure align-center" style="width: 340px">
<img alt="_images/tree2.png" src="_images/tree2.png" />
</div>
<p>Policzmy rentowności.</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Ścieżka 1</dt><dd><p><span class="math notranslate nohighlight">\(1.04\times1.047\times1.054 = 1.148 \text{ czyli } 14.8 \%\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Ścieżka 2</dt><dd><p><span class="math notranslate nohighlight">\(1.04\times1.047\times1.045 = 1.138 \text{ czyli }13.8 \%\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Ścieżka 3</dt><dd><p><span class="math notranslate nohighlight">\(1.04\times1.038\times1.045 = 1.128 \text{ czyli }12.8 \%\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Ścieżka 4</dt><dd><p><span class="math notranslate nohighlight">\(1.04\times1.038\times1.036 = 1.118 \text{ czyli } 11.8 \%\)</span></p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Skumulowany zwrot po trzech okresach (np. latach) wynosi:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2} \langle 1.148 + 1.138 + 1.128 + 0.25 x 1.118 \rangle = 1.133\]</div>
<p>Zanualizowany zwrot po trzech okresach <span class="math notranslate nohighlight">\(S(3)\)</span> wynosi:</p>
<div class="math notranslate nohighlight">
\[\sqrt[3]{ 1.128} - 1 = S(3) \text{ czyli  około } 4.25\%\]</div>
<p>W podobny sposób dla dowolnych ścieżek możemy obliczać odpowiednie
stopy. Jednak ze względu na wykładniczy wzrost liczby ścieżek z liczbą
okresów warto zastosować komputer do obliczenia średniej po
ścieżkach. Spróbujmy więc zaimplementować powyższy algorytm
korzystając z systemu Sage.</p>
<p>Po pierwsze zdefiniujmy sobie procedurę, która będzie generowała
rekombinujące drzewo binarne. Nazwijmy tą funkcję <code class="code docutils literal notranslate"><span class="pre">gen_recombining()</span></code>,
jej szczegółowy opis znajduję się w <a class="reference internal" href="binarne.html#binarne"><span class="std std-ref">Dodatek: Komputerowa analiza drzew binarnych</span></a>.</p>
<p>Drzewo w którym wszystkie wartości rekombinują posiada <span class="math notranslate nohighlight">\(n+1\)</span>
wartosci w <span class="math notranslate nohighlight">\(n\)</span> - tym okresie. Mamy dwie proste reguły prowadzące
do tego typu drzew. Jedną jest odejmowanie i dodawania tych samych
wartości, co ma to jednak tę wadę, że możemy wygenerować ujemną stopę
procentową. Drugą możliwością jest mnożenie wartości stopy procentowej
w przypadku wzrostu przez pewną liczbę większą od jednego, a w
przypadku zmalenia przez jej odwrotność. Łatwo się przekonać, że takie
działanie zawsze prowadzi do drzewa rekombinującego.</p>
<div class="admonition-poeksperymentuj-sam admonition">
<p class="admonition-title">Poeksperymentuj sam</p>
<p>Wykonaj poniższy kod!</p>
</div>
<div class='sage_linked'><script type='text/x-sage'>def gen_recombining(niter,SP = 4.0,q=0.175,delta1=None,delta2=None):
    SP = [[SP]]

    for i in range(niter):
        tmp = []
        for s in SP[-1]:
            if delta1==None or delta2==None:
                tmp+= [ (1+q)*s]
            else:
                tmp+= [ s+delta1]

        if delta1==None or delta2==None:
            tmp+= [ s/(1+q)]
        else:
            tmp+= [ s-delta2]
        SP.append(tmp)
    return SP
print( "Na przyklad gen_recombining(3) daje:" )
table(gen_recombining(3))</script></div><p>Do wizualizacji danych możemy wykorzystać również system Sage i
przykładowa procedura rysującą drzewa w obu formatach ma następującą
postać:</p>
<div class='sage_linked'><script type='text/x-sage'>def plot_tree(SP):
    plt = point( (0,SP[0][0]),size=244,color='gray',alpha=0.2,zorder=0)

    if len(SP) == len(SP[-1]):
        for l,prices in enumerate(SP):
            for i,p in enumerate(prices):
                if l>0:
                    plt+=point2d( (l,p),size=244,\
                     color='gray',alpha=0.2,zorder=0,faceted=True )
                    plt+= text("%0.1f"%p,(l,p),color='black',\
                     figsize=(5,3))

        for l in range(len(SP)-1):
            for i in range(l+1):
                plt+=arrow2d( (l,SP[l][i]),(l+1,SP[l+1][i]),\
                  arrowshorten=16)
                plt+=arrow2d( (l,SP[l][i]),(l+1,SP[l+1][i+1]),\
                   arrowshorten=16)
    else:
        for l,prices in enumerate(SP):
            for i,p in enumerate(prices):
                if l>0:
                    plt+=arrow2d( (l-1,SP[l-1][int(i/2)]),(l,p),\
                      arrowshorten=16)
                    plt+=point2d( (l,p),size=244,color='gray',\
                      alpha=0.2,zorder=0,faceted=True )
                    plt+= text("%0.1f"%p,(l,p),color='black',\
                      figsize=(5,3))
    plt.axes_labels(["rok","stopa procentowa [%]"])
    plt.axes_range(xmin=-.2, xmax = len(SP)-1+0.2,\
     ymin=0,ymax=SP[-1][0]+1)
    return plt</script></div><p>Teraz możemy narysować drzewo do np. czwartej generacji i tak wywołanie:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span> <span class="n">gen_recombining</span><span class="p">(</span><span class="n">SP</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>powinno dać:</p>
<div class="math notranslate nohighlight">
\[\left[4.0\right]
\left[4.7, 3.4\right]
\left[5.5, 4.0, 2.9\right]
\left[6.5, 4.7, 3.4, 2.5\right]\]</div>
<div class="admonition-poeksperymentuj-sam admonition">
<p class="admonition-title">Poeksperymentuj sam</p>
<p>Wykonaj poniższy kod dla różnych parametrów,
<code class="code docutils literal notranslate"><span class="pre">niter,SP,q=0.175,delta1,delta2</span></code>!</p>
</div>
<div class='sage_linked'><script type='text/x-sage'>plot_tree(gen_recombining(3))</script></div><p>Obliczanie wartości średnich w modelu dwumiennym wiąże się z
sumowaniem po wszystkich ścieżkach. Ponieważ rozważania dla stóp
procentowych mają sens dla kilku - maksymalnie kilkunastu lat to można
sobie pozwolić na dokładne wykonanie takich obliczeń. Liczba
składników sum będzie np. <span class="math notranslate nohighlight">\(65536\)</span> dla <span class="math notranslate nohighlight">\(n=16\)</span>.</p>
<div class="figure align-center" style="width: 340px">
<img alt="_images/tree4.png" src="_images/tree4.png" />
</div>
<p>Mając drzewo binarne, możemy policzyć średnią zanulizowaną stopę
procentową. Algorytm, można zapisać w trzech liniach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">SP</span> <span class="o">=</span> <span class="n">gen_recombining</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">delta1</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span><span class="n">delta2</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">all_paths</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span> <span class="p">))</span>
<span class="n">mean</span><span class="p">(</span> <span class="p">[</span><span class="n">prod</span><span class="p">([(</span><span class="mi">1</span><span class="o">+</span><span class="mf">0.01</span><span class="o">*</span><span class="n">SP</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path_</span><span class="p">)])</span> <span class="k">for</span> <span class="n">path_</span> <span class="ow">in</span> <span class="n">all_paths</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<div class="admonition-opis-programu admonition">
<p class="admonition-title">Opis programu</p>
<p>Chcemy policzyć średnią z iloczynów <span class="math notranslate nohighlight">\(\prod_{i=1}^{n} (1+r_i)\)</span>
po wszystkich ścieżkach. Postępujęmy w następujący sposób:</p>
<ul>
<li><p><strong>linia 1:</strong> - generujemy drzewo (rekombinujące) wszystkich wartości stóp:
<code class="code docutils literal notranslate"><span class="pre">SP</span> <span class="pre">=</span> <span class="pre">gen_recombining(N,...</span></code></p></li>
<li><p><strong>linia 2:</strong> - wyliczamy wszystkie ścieżki w formacie
np. [0,1,2,1,…], gdzie kolejne liczby oznaczają pozycję danej
stopy w odpowiednim okresie. W przykładzie, w trzecim okresie
mamy stopę numer „2” na liście stóp. Obliczenia te wykorzystują
iloczyn kartezjanski, który w Sage mamy w postaci funkcji np. dla
dwóch list: <code class="code docutils literal notranslate"><span class="pre">cartesian_product([[0,1],[0,1]])</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>zauważmy, że pierwsza gwiazdka „rozpakowywuje argumenty” z <code class="code docutils literal notranslate"><span class="pre">N*[[0,1]]</span></code>.</p></li>
<li><p>użycie <code class="code docutils literal notranslate"><span class="pre">np.cumsum</span></code> umożliwia z zapisu względnych ruchów
stopy w okresach <code class="code docutils literal notranslate"><span class="pre">[0,1,0,0,1]</span></code> do jej bezwględnych
indeksów wartości <code class="code docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">2]</span></code>.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>linia 3:</strong> -  mając już zapis każdej ścieżki w powyższym formacie, wykonujemy
odpowiedni iloczyn oraz uśredniamy wynik po ścieżkach</p></li>
</ul>
</div>
<p>Możemy sprawdzić czy powyższy program obliczy poprawnie testując go na
przeliczonym w uprzednio <span class="xref std std-ref">przykładzie</span>:</p>
<div class='sage_linked'><script type='text/x-sage'>import numpy as np
N = 2
try:
    SP = gen_recombining(N,delta1=0.7,delta2=0.2)
    all_paths = map(lambda x:[0]+np.cumsum(x).tolist(), map(list,cartesian_product(N*[[0,1]]).list() ))
    R = mean( [prod([(1+0.01*SP[i][p]) for i,p in enumerate(path_)]) for path_ in all_paths] )
    print( "Srednia zannualizowana stopa wynosi:", (R^(1/(N+1)) - 1)*100 )
except:
    print( "załaduj definicję get_recombining" )</script></div><p>Wykonując powyższą komórkę powinniśmy otrzymać wynik taki sam jak w
rachunkach „na piechotę”. Po co nam więc algoryym? Rachunków „na piechotę”
nie da się przeprowadzać dla zbyt dużej ilości okresów, bo liczba
scieżek rośnie wykładniczo jak <span class="math notranslate nohighlight">\(2^N\)</span>! A w następnym rozdziale
będziemy potrzebowali wyników dla <span class="math notranslate nohighlight">\(N&gt;10\)</span>.</p>
<div class="section" id="krzywa-dochodowosci-w-modelu-dyskretnym">
<h3><span class="section-number">7.3.1. </span>Krzywa dochodowości w modelu dyskretnym<a class="headerlink" href="#krzywa-dochodowosci-w-modelu-dyskretnym" title="Stały odnośnik do tego nagłówka">¶</a></h3>
<p>Mając napisany algorytm do oblicznania średniej zanualizowanej stopy,
możemy policzyć krzywą dochodowości w modelu dwumiennym. W tym celu
liczymy, zakładając ewolucję stopy zgodnie z regułami-
multyplikatywną lub addytywną, stopę <span class="math notranslate nohighlight">\(r_s\)</span> dla różnych ilości
okresów i nanosimy otrzymane wartości na wykresie
<span class="math notranslate nohighlight">\(r_s(N)\)</span>. Mamy:</p>
<div class="figure align-center" id="id3" style="width: 340px">
<a class="reference internal image-reference" href="_images/krzywa_dochodowosci1.png"><img alt="_images/krzywa_dochodowosci1.png" src="_images/krzywa_dochodowosci1.png" style="height: 230px;" /></a>
<p class="caption"><span class="caption-text">Krzywa rentowności dla ewolucji stopy procentowej modelowanej
procesem binarnym</span><a class="headerlink" href="#id3" title="Stały odnośnik do tego obrazu">¶</a></p>
</div>
<p>Implementacja algorytmu w zasadzie polega na umieszczeniu kodu
liczącego zanulizowaną średnią stopę po <span class="math notranslate nohighlight">\(N\)</span> okresach wewnątrz
funkcji, w której parametrem będzie właśnie liczba okresów.</p>
<div class="admonition-poeksperymentuj-sam admonition">
<p class="admonition-title">Poeksperymentuj sam</p>
<p>W funkcji <code class="code docutils literal notranslate"><span class="pre">forward_rate(N</span> <span class="pre">=</span> <span class="pre">2,**kpars)</span></code> oznaczenie
<code class="code docutils literal notranslate"><span class="pre">**kpars</span></code> umożliwia przekazanie dowolnej ilości argumentów,
które będą potem przekazane dalej do
<code class="code docutils literal notranslate"><span class="pre">gen_recombining(N,**kpars)</span></code>. Można na przykład zastosować
wywołanie z drzewem addytywnym. Jak wtedy będzie wyglądała ta
krzywa?</p>
</div>
<div class='sage_linked'><script type='text/x-sage'>def forward_rate(N = 2,**kpars):

    SP = gen_recombining(N,**kpars)

    all_paths = map(lambda x:[0]+np.cumsum(x).tolist(), map(list,cartesian_product(N*[[0,1]]).list() ))


    r_avg = mean( [prod([(1+0.01*SP[i][p]) for i,p in enumerate(path_)]) for path_ in all_paths] )
    rs  =((r_avg)^(1/(N+1))-1)*100
    return  rs


point( [(i,forward_rate(i,q=0.1)) for i in range(1,12)],figsize=5)+\
 point( [(i,forward_rate(i,q=0.2)) for i in range(1,12)],color='red')</script></div></div>
</div>
<div class="section" id="modele-ciagle-ewolucji-stop-procentowych">
<h2><span class="section-number">7.4. </span>Modele ciągłe ewolucji stóp procentowych<a class="headerlink" href="#modele-ciagle-ewolucji-stop-procentowych" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Ewolucję stopy procentowej można też modelować procesem losowym z
czasem ciągłym. Modele takie dzielą się na:</p>
<blockquote>
<div><ul class="simple">
<li><p>jednofaktorowe: takie w których mamy jedno równanie stochastyczne</p></li>
<li><p>wielofaktorowe: mamy dwa lub więcej równań stochastycznych</p></li>
</ul>
</div></blockquote>
<p>Wszystkie te modele są zbudowane na podstawie teorii o bardzo podobnych założeniach jak model Blacka-Scholesa.
Rozważmy, bezkuponową obligację skarbową istniejący na rynku z ciągła kapitalizacją odsetek. <em>Yield to Maturity</em> takiej obligacji spełnia równanie:</p>
<p>gdzie <span class="math notranslate nohighlight">\(P(t,t+T)\)</span> to cena tej obligacji w chwili <span class="math notranslate nohighlight">\(t\)</span> a <span class="math notranslate nohighlight">\(T\)</span> to okres czasu po jakim on zapada. Rozwiązując to równanie na YTM dostajemy:</p>
<div class="math notranslate nohighlight" id="equation-ytm-p">
<span class="eqno">(5)<a class="headerlink" href="#equation-ytm-p" title="Stały odnośnik do tego równania">¶</a></span>\[Y(t,T) = -\frac{1}{T}\log(P(t,t+T)).\]</div>
<p>Z drugiej strony średnia po czasie z ciągłej stopy forward daje wewnętrzną stopę zwrotu w okresie do zapadalności:</p>
<div class="math notranslate nohighlight" id="equation-ytm-f">
<span class="eqno">(6)<a class="headerlink" href="#equation-ytm-f" title="Stały odnośnik do tego równania">¶</a></span>\[Y(t,T) = \frac{1}{T}\int_t^{t+T} F(t,s)ds.\]</div>
<p>Z powyższych dwóch równań otrzymujemy związek między ciągłą stopą forward a ceną rozważanej obilgacji:</p>
<div class="math notranslate nohighlight" id="equation-f-ytm">
<span class="eqno">(7)<a class="headerlink" href="#equation-f-ytm" title="Stały odnośnik do tego równania">¶</a></span>\[F(t,s) = -\frac{\partial}{\partial s} \log P(t,s).\]</div>
<p>Załóżmy, że chwilowa stopa procentowa jest procesem losowym spełniającym następujące równanie stochastyczne</p>
<div class="math notranslate nohighlight" id="equation-sde">
<span class="eqno">(8)<a class="headerlink" href="#equation-sde" title="Stały odnośnik do tego równania">¶</a></span>\[dr = \mu(r,t) dt + \sigma(r,t) dW\]</div>
<p>Ponieważ cena obligacji jest funkcją tego procesu, zastosujemy wzór Ito (patrz skrypt  <a class="reference external" href="http://prac.us.edu.pl/~ekonofiz//skrypty/StochDyn/ch3/chIII030.html#rachunek-rozniczkowy-ito">Dynamika Stochastyczna</a>:</p>
<div class="math notranslate nohighlight">
\[dP = \left(  \frac{\partial P}{\partial t} + \mu(r,t) \frac{\partial P}{\partial r} +\frac{\sigma(r,t)^2}{2} \frac{\partial^2 P}{\partial r^2} \right) dt +  \sigma(r,t)\frac{\partial P}{\partial r} dW\]</div>
<p>Dzieląc przez <span class="math notranslate nohighlight">\(dt\)</span> i uśredniając  po realizacjach procesu losowego otrzymujemy:</p>
<div class="math notranslate nohighlight" id="equation-dpdt">
<span class="eqno">(9)<a class="headerlink" href="#equation-dpdt" title="Stały odnośnik do tego równania">¶</a></span>\[\langle \frac{dP}{dt}\rangle = \frac{\partial P}{\partial t} + \mu(r,t) \frac{\partial P}{\partial r} +\frac{\sigma(r,t)^2}{2} \frac{\partial^2 P}{\partial r^2}\]</div>
<p>Teraz należy poczynić założenia co do ewolucji wielkości oczekiwanej: <span class="math notranslate nohighlight">\(\langle \frac{dP}{dt}\rangle\)</span>. Można by przypuszczać, że średnia cena takiej obligacji powinna rosnąć zgodnie z równaniem:</p>
<div class="math notranslate nohighlight">
\[\langle \frac{dP}{dt}\rangle = r P,\]</div>
<p>Jednak przyjmuje się, że w sytuacji gdy mamy ryzyko wzrost ten powinien być większy by skompensować ewentualne straty. Dlatego wprowadza się dodatkowy parametr, który jest zwany <em>risk premium</em> i równanie to przybiera postać:</p>
<div class="math notranslate nohighlight" id="equation-riskpremium">
<span class="eqno">(10)<a class="headerlink" href="#equation-riskpremium" title="Stały odnośnik do tego równania">¶</a></span>\[ \langle \frac{dP}{dt}\rangle = r (1-\lambda) P.\]</div>
<p>Podstawiając do równanie <a class="reference internal" href="#equation-riskpremium">(10)</a> do <a class="reference internal" href="#equation-dpdt">(9)</a> otrzymujemy cząstkowe równanie różniczkowe na cenę obligacji bezkuponowej z losową stopą procentową daną przez <a class="reference internal" href="#equation-sde">(8)</a>.</p>
<div class="math notranslate nohighlight" id="equation-pde-bon">
<span class="eqno">(11)<a class="headerlink" href="#equation-pde-bon" title="Stały odnośnik do tego równania">¶</a></span>\[\frac{\partial P}{\partial t} + \mu(r,t) \frac{\partial P}{\partial r} +\frac{\sigma(r,t)^2}{2} \frac{\partial^2 P}{\partial r^2} - r (1-\lambda) P\]</div>
<p>Powyższe rozważania są dość ogólne, zauważmy, że nie podaliśmy jawnych postaci funkcji <span class="math notranslate nohighlight">\(\sigma(r,t)\)</span> i <span class="math notranslate nohighlight">\(\mu(r,t)\)</span>. Jednym z podstawowych modeli jednofaktorowych jest tzw. model Vasicek’a, w którym chwilowa stopa zwrotu dana jest równaniem:</p>
<div class="math notranslate nohighlight" id="equation-vasicek-sde">
<span class="eqno">(12)<a class="headerlink" href="#equation-vasicek-sde" title="Stały odnośnik do tego równania">¶</a></span>\[\frac{dr}{dt} = \alpha \left( \gamma  - r(t) \right) + \sigma \xi(t),\]</div>
<p>gdzie:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(r(t)\)</span> - chwilowa stopa zwrotu</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda\)</span> - prędkość relaksacji</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma\)</span> -   wartość asymptotyczna procesu</p></li>
<li><p><span class="math notranslate nohighlight">\(\xi(t)\)</span> - biały szum Gaussowski z funkcją korelacji:
<span class="math notranslate nohighlight">\(\langle x(t) x(t+\tau) \rangle = \delta(\tau)\)</span></p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Informacja</p>
<p>Proces ten jest też zwany procesem Ornsteina-Uhlenbecka i w fizyce może być interpretowany jako dynamika przetłumionego oscylatora harmonicznego z szumem.</p>
</div>
<p>Jesli zastosujemy model Vasicka <a class="reference internal" href="#equation-vasicek-sde">(12)</a>  to równanie <a class="reference internal" href="#equation-pde-bon">(11)</a> upraszcza się do:</p>
<div class="math notranslate nohighlight" id="equation-vasicek-pde">
<span class="eqno">(13)<a class="headerlink" href="#equation-vasicek-pde" title="Stały odnośnik do tego równania">¶</a></span>\[\frac{\partial P}{\partial t} + \alpha \left( \gamma  - r \right) \frac{\partial P}{\partial r} +\frac{\sigma^2}{2} \frac{\partial^2 P}{\partial r^2} - r (1-\lambda)P\]</div>
<p>Okazuje się, że to równanie można rozwązać dokładnie i rozwiązanie bez czynnika <em>risk premium</em> jest w postaci:</p>
<div class="math notranslate nohighlight">
\[P(r,0,T) = Ae^{-Br},\]</div>
<p>gdzie:</p>
<div class="math notranslate nohighlight">
\[\begin{split}B = \frac{1}{\alpha} (1-e^{-\alpha T}) \\
A = \exp\left\{ (\gamma-\frac{\sigma^2}{2 \alpha^2}) (B-T) - \frac{\sigma^2}{4\alpha} B^2 \right\}\end{split}\]</div>
<p>Uwzględnienie czynnika <span class="math notranslate nohighlight">\(\lambda\)</span> sprowadza się do zastąpienia pamametrów <span class="math notranslate nohighlight">\(\alpha,\gamma\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\alpha \to \alpha + \lambda\sigma \\
\gamma \to \alpha \frac{\gamma}{\alpha+\lambda \sigma}\end{split}\]</div>
<div class='sage_linked'><script type='text/x-sage'>def Bvas(r,alfa=1.0,gama=0.06,sigma=0.02,T=1.0,lamb=0.667):

    alfa, gama = alfa + lamb*sigma, alfa*gama/(alfa+lamb*sigma)
    B = 1/alfa*(1-exp(-alfa*T))
    A = exp( (gama-sigma^2/(2*alfa^2))*(B-T) - sigma^2/(4*alfa)*B^2 )
    return A*exp(-B*r)</script></div><div class="admonition-poeksperymentuj-sam admonition">
<p class="admonition-title">Poeksperymentuj sam</p>
<p>Wykonaj poniższy kod implementujący wzór na cenę zerokuponowej obligacji. Narysuj krzywą dochodowości,
czyli <em>Yield to Maturity</em> dla tej obligacji. Poeksperymentuj z poniższą komórką i parametrami.</p>
</div>
<div class='sage_linked'><script type='text/x-sage'>Rexact = [(t,-log( Bvas(r=0.03,alfa=1.0,gama=0.06,sigma=0.02,T=t,lamb=0.667))/t) for t in srange(0.01,15,.1)]
point ( Rexact,color='red')</script></div><p>Możemy sobie łatwo skonstruować algorytm, który będzie symulował to
równanie stochastyczne <a class="reference internal" href="#equation-vasicek-sde">(12)</a>. Ponieważ potrzebujemy wiele realizacji procesu
losowego, najlepiej będzie symulować jednocześnie <span class="math notranslate nohighlight">\(M\)</span> trajektorii.</p>
<div class='sage_linked'><script type='text/x-sage'>import numpy as np

N = 4400
M = 2301
T = 13.
h = T/(N-1)
time = np.linspace(0,T,N)
r0 = 0.03
sigma = 0.02
gama = 0.06
alfa = 1.0
lamb = 0.667


alfa1 = alfa + lamb*sigma
gama1 = alfa*gama/(alfa+lamb*sigma)

x = np.zeros((M,N))
x[:,0] = r0*np.ones(M)
for i in range(1,N):
  x[:,i] = x[:,i-1] + alfa1*(gama1-x[:,i-1])*h + sigma*np.sqrt(h)*np.random.randn(M)</script></div><div class="admonition-opis-programu admonition">
<p class="admonition-title">Opis programu</p>
<p>Wykorzystujemy stochastyczny algorytm Eulera w którym całka z
białego szumu  jest równa:</p>
<div class="math notranslate nohighlight">
\[\int_0^h \xi(t) dt = \sqrt{h} N(0,1),\]</div>
<p>gdzie <span class="math notranslate nohighlight">\(N(0,1)\)</span> jest zmienną losową o rozkładzie Gaussowskim
ze średnią zero i wariancją <span class="math notranslate nohighlight">\(1\)</span>.</p>
<ul class="simple">
<li><p>inicjalizujemy macierz <code class="code docutils literal notranslate"><span class="pre">x</span></code> w której będziemy przechowywać wszystkie
<span class="math notranslate nohighlight">\(N\)</span> kroków dla <span class="math notranslate nohighlight">\(M\)</span> trajektorii</p></li>
<li><p>w pierwszej kolumnie tej macierzy umieszczamy wartości
początkowe dla wszystkich realizacji - <code class="code docutils literal notranslate"><span class="pre">x[:,0]</span> <span class="pre">=</span> <span class="pre">r0*np.ones(M)</span></code></p></li>
</ul>
</div>
<p>Mając już wygenerowane trajektorie możemy je narysować:</p>
<div class='sage_linked'><script type='text/x-sage'>sum([line( zip(time[::1],x[i,::1]),thickness=0.1 ) for i in range(20)])</script></div><p>Pozostaje tylko obliczenie krzywej dochodowości z symulacji stochastycznej i porównanie jej z wynikiem analitycznym:</p>
<div class='sage_linked'><script type='text/x-sage'>P = np.average(np.exp(-np.cumsum(x,axis=1)*h),axis=0)
pDR = -np.log(P)[1:]/time[1:]

pltMC = line( zip(time,pDR),gridlines=[[],[gama+sigma*lamb/alfa-sigma^2/(2*alfa^2)] ])
Rexact = [(t,-log( Bvas(r=r0,alfa=alfa,gama=gama,sigma=sigma,T=t,lamb=0.667))/t) for t in srange(0.01,15,.1)]
point ( Rexact,color='red')+   pltMC</script></div><div class="admonition-opis-programu admonition">
<p class="admonition-title">Opis programu</p>
<ul class="simple">
<li><p>wykonujemy równoczesną symulację <span class="math notranslate nohighlight">\(N\)</span> trajektorii</p></li>
<li><p>w linii <code class="code docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">np.average(np.exp(-np.cumsum(x,axis=1)*h),axis=0)</span></code> obliczamy cenę obligacji
dla każdej z realizacji procesu stopy i uśredniamy</p></li>
<li><p>linia  <code class="code docutils literal notranslate"><span class="pre">pDR</span> <span class="pre">=</span> <span class="pre">-np.log(P)[1:]/time[1:]</span></code> oblicza YTM dla obligacji z jej ceny.</p></li>
</ul>
</div>
</div>
<div class="section" id="podsumowanie">
<h2><span class="section-number">7.5. </span>Podsumowanie<a class="headerlink" href="#podsumowanie" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Struktura terminowa rynku stóp procentowych jest jednoznacznie opisana przez każdą z poniższych wielkości:</p>
<blockquote>
<div><ul class="simple">
<li><p>cenę obligacji zerokuponowych <span class="math notranslate nohighlight">\(P(t,s)\)</span></p></li>
<li><p><em>Yield to Maturity</em> tych obligacji <span class="math notranslate nohighlight">\(Y(t,s)\)</span></p></li>
<li><p>stopy forward <span class="math notranslate nohighlight">\(F(t,s)\)</span></p></li>
</ul>
</div></blockquote>
<p>Formuły  <code class="xref eq docutils literal notranslate"><span class="pre">P_YTM</span></code> <a class="reference internal" href="#equation-ytm-p">(5)</a> <a class="reference internal" href="#equation-f-ytm">(7)</a> <a class="reference internal" href="#equation-ytm-f">(6)</a>, oraz ich dyskretne odpowiedniki umożliwiają przeliczenie jednej wielkości w drugą.</p>
<p>W modelowaniu struktury stop procentowych zazwyczaj zakłada się pewien model ewolucji stochastycznej chwilowej stopy procentowe. Z tego modelu metodami analitycznymi lub poprzez symulacje  wycenia się obligaję zerokuponową. Mając wyznaczoną tą wielkość (<span class="math notranslate nohighlight">\(P(t,s)\)</span>) struktura terminowa rynku stop procentowych jednoznacznie określona.</p>
<p>Stopy forwards są potrzebne do obliczania parametrów FRA</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div class="sphinxlocaltoc">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. Struktura  terminowa stóp procentowych</a><ul>
<li><a class="reference internal" href="#podstawowe-zaleznosci">7.1. Podstawowe zależności</a></li>
<li><a class="reference internal" href="#krzywa-dochodowosci">7.2. Krzywa dochodowości</a></li>
<li><a class="reference internal" href="#modele-dyskretne-ewolucji-stop-procentowych">7.3. Modele dyskretne ewolucji stóp procentowych</a><ul>
<li><a class="reference internal" href="#krzywa-dochodowosci-w-modelu-dyskretnym">7.3.1. Krzywa dochodowości w modelu dyskretnym</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modele-ciagle-ewolucji-stop-procentowych">7.4. Modele ciągłe ewolucji stóp procentowych</a></li>
<li><a class="reference internal" href="#podsumowanie">7.5. Podsumowanie</a></li>
</ul>
</li>
</ul>

  </div>
  <h4>Poprzedni temat</h4>
  <p class="topless"><a href="instrumenty_stalego_dochodu.html"
                        title="poprzedni rozdział"><span class="section-number">6. </span>Instrumenty stałego dochodu</a></p>
  <h4>Następny temat</h4>
  <p class="topless"><a href="forex.html"
                        title="następny rozdział"><span class="section-number">8. </span>Pewne aspekty wymiany walut</a></p>
  <div role="note" aria-label="source link">
    <h3>Ta strona</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/stopy_procentowe.rst.txt"
            rel="nofollow">Pokaż źródło</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Szybkie wyszukiwanie</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Szukaj" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  </div>
  <div class="relbar-bottom">
    
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Nawigacja</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Indeks ogólny"
             >indeks</a></li>
        <li class="right" >
          <a href="forex.html" title="8. Pewne aspekty wymiany walut"
             >dalej</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="instrumenty_stalego_dochodu.html" title="6. Instrumenty stałego dochodu"
             >wstecz</a> &nbsp; &nbsp;</li>
  <li><a href="index.html">Analiza Rynków Finansowych</a> &#187;</li>
  
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7. </span>Struktura  terminowa stóp procentowych</a></li> 
      </ul>
    </div>
  </div>
  
  <div class="footer">
    <a class="logo" href="http://upgow.us.edu.pl/" target="_blank"><img src="_static/upgow.png" alt="UPGOW"/></a><br/>
    <img src="_static/stopka_EU.png" alt="EU"/><br/>
    &copy; Copyright 2013, ML and MK.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.2.1.
  </div>
  </body>
</html>