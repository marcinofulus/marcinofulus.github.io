

  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Metody wyznaczania ceny opcji &mdash; Analiza Rynków Finansowych</title>
    
    <link rel="stylesheet" href="_static/upgow.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono&subset=latin,latin-ext" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="_static/cloud.js"></script>

	<script src="http://sagecell.icse.us.edu.pl:6363/static/jquery.min.js"></script>
	<script src="http://sagecell.icse.us.edu.pl:6363/static/embedded_sagecell.js"></script>


	<script>sagecell.makeSagecell({inputLocation: ".sage",
                                       evalButtonText: 'Wykonaj',
                                       linked: true});</script>

	<style type="text/css">
		.sagecell .CodeMirror-scroll {
			overflow-y: hidden;
			overflow-x: auto;
		}
		.sagecell .CodeMirror {
			height: auto;
		}
	</style>

    
    <link rel="top" title="Analiza Rynków Finansowych" href="http://visual.icse.us.edu.pl/ARF/index.html" />
    <link rel="next" title="8. Instrumenty syntetyczne" href="http://visual.icse.us.edu.pl/ARF/Instrumenty_syntetyczne.html" />
    <link rel="prev" title="6. Opcje" href="http://visual.icse.us.edu.pl/ARF/opcje.html" />
 
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
  </head>
  <body>
  <div class="relbar-top">
    
    <div class="related">
      <h3>Nawigacja</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http://visual.icse.us.edu.pl/ARF/genindex.html" title="Indeks ogólny"
             accesskey="I">indeks</a></li>
        <li class="right" >
          <a href="http://visual.icse.us.edu.pl/ARF/Instrumenty_syntetyczne.html" title="8. Instrumenty syntetyczne"
             accesskey="N">dalej</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="http://visual.icse.us.edu.pl/ARF/opcje.html" title="6. Opcje"
             accesskey="P">wstecz</a> &nbsp; &nbsp;</li>
  <li><a href="http://visual.icse.us.edu.pl/ARF/index.html">Analiza Rynków Finansowych</a> &raquo;</li>
   
      </ul>
    </div>
  </div>
  
  <div class="content">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="metody-wyznaczania-ceny-opcji">
<h1>7. Metody wyznaczania ceny opcji<a class="headerlink" href="opcje-wycena.html#metody-wyznaczania-ceny-opcji" title="Stały odnośnik do tego nagłówka">¶</a></h1>
<div class="section" id="jak-wyznaczyc-cene-opcji">
<h2>7.1. Jak wyznaczyć cenę opcji?<a class="headerlink" href="opcje-wycena.html#jak-wyznaczyc-cene-opcji" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Wyznaczenie ceny opcji polega na tym by określić jej wartość godziną w
dowolnej chwili czasu. Wartość zależy od ceny aktywa w przyszłości a
ta z kolei zmienia się w losowy sposób.  Niestety, nie ma sposobu by
znać tę wartość z wyprzedzeniem.</p>
<p>Dlatego aby wyznaczyć cenę opcji posługujemy się modelami
teoretycznymi.  Istnieje wiele modeli stosowanych do tego
celu. Wszystkie modele zakładają, że proces ewolucji ceny aktywa jest
jest pewnym procesem losowym. Ponadto zakładamy, że mamy do czynienia
z rynkiem wolnym od arbitrażu na którym można bez ograniczeń i
prowizji handlowac dowolną ilością aktywów.</p>
<p>Najprostszym modelem jest dwumianowy model wyceny opcji. (<em>Cox,
Ross, Rubinstein, &#8220;Option pricing: Simplified Approach&#8221;, Journal of
Financial Economics- September 1979</em>). Ten model wycenia europejską
opcję call na akcje spółki nie wypłacającej dywidendę.</p>
<p>W modelu dwumianowym czas pozostały do wygaśnięcia opcji dzieli się na
dyskretne przedziały. Po każdy okresie czasu cena aktywa <span class="math">\(P\)</span>
zmienia się przyjmując jeden z dwu możliwych stanów. Może wzrosnąć do
wartości Pu (z prawdopodobieństwem p) lub zmaleć do wartości Pd (z
prawdopodobieństwem <span class="math">\(1-p\)</span>), gdzie <span class="math">\(u &gt; 1\)</span>, <span class="math">\(d &lt;
1\)</span>. Mając zbiór cen aktywa (np. akcji) w postaci drzewka, można
wycenić opcję przeprowadzając rachunek wstecz, począwszy od daty
wygaśnięcia.  Obliczenia wykonuje się w kierunku początku drzewa od
chwili <span class="math">\(T\)</span> do <span class="math">\(T-1\)</span>, dyskontując w tym przedziale czasowym
wartość portfela bezpiecznego składającego się z aktywa i opcji, po
stopie procentowej wolnej od ryzyka. Procedurę powtarza się aż do
chwili wystawienia opcji. Modele te są opisane w szczególach w
rozdziale o opcjach binarnych <a class="reference internal" href="http://visual.icse.us.edu.pl/ARF/binarne.html#binarne"><em>Dodatek: Komputerowa analiza drzew binarnych</em></a>.</p>
</div>
<div class="section" id="model-minimalny-rynek-dwustanowy-jednookresowy">
<h2>7.2. Model minimalny - rynek dwustanowy jednookresowy<a class="headerlink" href="opcje-wycena.html#model-minimalny-rynek-dwustanowy-jednookresowy" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Rozważmy najprostszy rynek uwzględniający nieprzewidywalną zmienność.
Wyobraźmy sobie, że mamy pewne aktywo <span class="math">\(S\)</span>, które w chwili
początkowej <span class="math">\(t=0\)</span> posiada wartość <span class="math">\(S(t=0)=S_0\)</span>. Po czasie
<span class="math">\(T\)</span> dopuszczamy jeden z dwóch możliwych scenariuszy: aktywo
drożeje do wartości <span class="math">\(S_{up}\)</span> albo tanieje do wartości
<span class="math">\(S_{down}\)</span>. W tym momencie prawdopodobieństwa zajęcia każdego ze
scenariuszy są niewiadomą. Rynek jest jednookresowy, co oznacza, że
rozważamy tylko dwie chwile czasu: początkową: <span class="math">\(t=0\)</span> i przyszłą: <span class="math">\(t=T\)</span>.</p>
<p>Zakładamy, że na rynku istnieje możliwość ulokowania gotówki w depozyt
bankowy ze stopą procentową <span class="math">\(r\)</span>. Zakładamy, że taka operacja
jest pozbawiona jakiegokolwiek ryzyka. Innymi słowy po czasie
<span class="math">\(T\)</span> depozyt bankowy gwarantuje nam, że nasz kapitał będzie
wynosił <span class="math">\(S_0 e^{rT}\)</span>.</p>
<p>Kolejnym elementem stosowanym przy wycenie instrumentów co do których
przyszłości nie mamy pewności, jest pojęcie rynku wolnego od
arbitrażu. Arbitraż oznacza, że startując z pewnego kapitału możemy
zarobić - w sensie wartości średniej, kupując lub sprzedająć dostępne
instrumenty. Zarobek oznacza oczywiście, że po operacji będziemy mieli
więcej środków niż dał by nam depozyt bankowy. Oczywiście musimy wziąć
pod uwagę wartości średnie, jeśli występują losowo zmieniające się
aktywa.</p>
<p>Okazuje się, że jeśli przyjmiemy założenie rynku wolnego od arbitrażu,
to przy ustalonych stanach aktywa <span class="math">\(S_{up}\)</span> i <span class="math">\(S_{down}\)</span>,
prawdopodobieństwo tego, że aktywo podrożeje <span class="math">\(p\)</span> musi spełniać:</p>
<div class="math" id="equation-eq:Parb">
<span class="eqno">(1)</span>\[ p S_{up} + (1-p) S_{down} = S_0 e^{rT}\]</div>
<p>Dlaczego? Jeśli prawdopodobieństwo to było by większe, wtedy
moglibyśmy kupić aktywo i w sensie wartości średniej otrzymalibyśmy
więcej niż lokata bankowa. Arbitraż byłby możliwy. W przeciwnym
przypadku posiadając aktywo moglibyśmy je sprzedać i ulokować środki
na depozycie. Po okresie <span class="math">\(T\)</span> za wartość depozytu moglibyśmy
nabyć więcej jednostek aktywa niż mieliśmy na początku. Znowu
zyskaliśmy w sensie wartości średniej.</p>
<p>Równanie <a href="opcje-wycena.html#equation-eq:Parb">(1)</a> jest podstawą konstrukcji wszystkich metod
wyceny instrumentów finansowych. Korzystając z niego możemy się
przekonać jaka jest wartość instrumentu w chwili początkowej czyli
wycenić dany instrument.</p>
<p>Jeśli znamy, albo założymy, wartości cen po czasie <span class="math">\(T\)</span>, to
równanie <a href="opcje-wycena.html#equation-eq:Parb">(1)</a> jest równaniem na prawdopodobieństwo
<span class="math">\(p\)</span>. Możemy je wyliczyć. Wtedy mając wszystkie dane na temat
drzewa kombinacji, jesteśmy w stanie analizować proces ewolucji cen
różnych instrumentów na takim drzewie.</p>
</div>
<div class="section" id="wycena-opcji-na-drzewie-binarnym">
<h2>7.3. Wycena opcji na drzewie binarnym<a class="headerlink" href="opcje-wycena.html#wycena-opcji-na-drzewie-binarnym" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Ważne</p>
<p>Do analizy zachowania się ceny na drzewie będziemy korzystać z
kilku funkcji pomocniczych. Dlatego należy wczytać poniższą
komórkę:</p>
<div class='sage'><script type='text/x-sage'>import numpy as np
def gen_all(niter,SP = 4.0,q=0.175,delta1=None,delta2=None):
    SP = [[SP]]
    for i in range(niter):
        tmp = []
        for s in SP[-1]:
            if delta1==None or delta2==None:
                tmp+= [ (1+q)*s, s/(1+q) ]
            else:
                tmp+= [ s+delta1, s-delta2 ]
        SP.append(tmp)
    return SP
def gen_recombining(niter,SP = 4.0,q=0.175,delta1=None,delta2=None):
    SP = [[SP]]
    for i in range(niter):
        tmp = []
        for s in SP[-1]:
            if delta1==None or delta2==None:
                tmp+= [ (1+q)*s]
            else:
                tmp+= [ s+delta1]
        if delta1==None or delta2==None:
            tmp+= [ s/(1+q)]
        else:
            tmp+= [ s-delta2]


        SP.append(tmp)
    return SP

def plot_tree(SP):
    plt = point( (0,SP[0][0]),size=244,color='gray',alpha=0.2,zorder=0)

    if len(SP) == len(SP[-1]):
        for l,prices in enumerate(SP):
            for i,p in enumerate(prices):
                if l>0:
                    plt+=point2d( (l,p),size=244,color='gray',alpha=0.2,zorder=0,faceted=True )
                    plt+= text("%0.1f"%p,(l,p),color='black',figsize=(5,3))
        for l in range(len(SP)-1):
            for i in range(l+1):
                plt+=arrow2d( (l,SP[l][i]),(l+1,SP[l+1][i]), arrowshorten=16)
                plt+=arrow2d( (l,SP[l][i]),(l+1,SP[l+1][i+1]), arrowshorten=16)
    else:
        for l,prices in enumerate(SP):
            for i,p in enumerate(prices):
                if l>0:
                    plt+=arrow2d( (l-1,SP[l-1][int(i/2)]),(l,p), arrowshorten=16)
                    plt+=point2d( (l,p),size=244,color='gray',alpha=0.2,zorder=0,faceted=True )
                    plt+= text("%0.1f"%p,(l,p),color='black',figsize=(5,3))
    plt.axes_labels(["rok","wartosc"])
    plt.axes_range(xmin=-.2, xmax = len(SP)-1+0.2,ymin=0,ymax=SP[-1][0]+1)
    return plt

def plot_tree2(SP,OP):
    plt = point( (0,SP[0][0]),size=244,color='gray',alpha=0.2,zorder=0)

    if len(SP) == len(SP[-1]):
        for l,(prices,oprices) in enumerate(zip(SP,OP)):
            for i,(p,op) in enumerate(zip(prices,oprices)):
                if l>0:
                    plt+=point2d( (l,p),size=244,color='gray',alpha=0.2,zorder=0,faceted=True )
                    plt+= text("%0.1f"%op,(l,p),color='black',figsize=(5,3))
        for l in range(len(SP)-1):
            for i in range(l+1):
                plt+=arrow2d( (l,SP[l][i]),(l+1,SP[l+1][i]), arrowshorten=16)
                plt+=arrow2d( (l,SP[l][i]),(l+1,SP[l+1][i+1]), arrowshorten=16)
    else:
        for l,(prices,oprices) in enumerate(zip(SP,OP)):
            for i,(p,op) in enumerate(zip(prices,oprices)):
                if l>0:
                    plt+=arrow2d( (l-1,SP[l-1][int(i/2)]),(l,p), arrowshorten=16)
                    plt+=point2d( (l,p),size=244,color='gray',alpha=0.2,zorder=0,faceted=True )
                    plt+= text("%0.1f"%op,(l,p),color='black',figsize=(5,3))
    plt.axes_labels(["rok","wartosc"])
    plt.axes_range(xmin=-.2, xmax = len(SP)-1+0.2,ymin=0,ymax=SP[-1][0]+1)
    return plt

print  "OK - wczytano funkcje pomocnicze"</script></div></div>
<p>Rozważmy drzewo multiplikatywne i instrument o wartości początkowej
<span class="math">\(S_0\)</span>. Narysujmy drzewo możliwych scenariuszy po pięciu
miesiącach, przyjmując jeden okres modelu jako jeden miesiąc:</p>
<div class='sage'><script type='text/x-sage'>N = 5
SP = gen_recombining(N,SP=50,q=0.1224)
plot_tree(SP)</script></div><p>Niech roczna stopa procentowa wynosi 10% a cena wykupu opcji
<span class="math">\(K=50\)</span>. Łatwo się przekonać, że takie drzewo jest wolne od
arbitrażu dla miary określonej przez <span class="math">\(q=0.5073\)</span>.</p>
<div class='sage'><script type='text/x-sage'>q = 0.5073
Q = [q,1-q]
K = 50
r = 10.0
C  = exp(r/100*1/12.).n()</script></div><p>Aby wycenic opcje postępujemy w następujący sposób. W ostatnim okresie
cena europejskiej opcji kupna (call) zależy tylko od ceny aktualnej
aktywa oraz ceny wykupu i jest równa:</p>
<div class='sage'><script type='text/x-sage'>[max(0,s-K) for s in SP[N]]</script></div><p>Znając te liczby możemy obliczyć cenę opcji w przedostatnim okresie
rozliczeniowym. Skorzystamy z tym celu z równania <a href="opcje-wycena.html#equation-Parb">(?)</a>, dla ceny
nie aktywa podstawowoego ale opcji.  Zauważmy, że miarę martyngałową
obliczyliśmy z równania <a href="opcje-wycena.html#equation-Parb">(?)</a> dla cen opcji. Mamy więc:</p>
<div class="math">
\[S_{i} = e^{-r T}\left( p S^{+}_{i+1} +(1-p) S^{-}_{i+1} \right)\]</div>
<p>Możemy więc napisać następujący algorytm. Zaczynamy od ceny opcji w
chwili <span class="math">\(t=T\)</span> - czyli od prawej strony drzewa binarnego, która
jest dana przez <span class="math">\(\mathrm{max}(0,S-K)\)</span>. Następnie stosując wzrór
<a href="opcje-wycena.html#equation-eq:Parb">(1)</a> dla każdego rozgałędzienia z osobna wyliczamy ceny
arbitrażowe dla czasu o jeden okres wcześniej.  Podstępując dalej w
ten sposób możemy otrzymać całe drzewo cen:</p>
<div class='sage'><script type='text/x-sage'>OP = [ [max(0,s-K) for s in SP[N]] ]
for idx in range(N):
    el = [ 1/C*(q*OP[-1][i]+(1-q)*OP[-1][i+1]) for i in range(len(OP[-1])-1)]
    OP.append(el)
OP.reverse()

print "Cena opcji:",OP[0]
plot_tree2(SP,OP)</script></div><p>Można jeszcze sobie zadać pytanie jaką intepretacje mają poszczególne
ceny w okresach pośrednich?  Weżmy z powyższego rysunku punkt z ceną
<span class="math">\(8.2\)</span>. Jest to cena opcji okresie <span class="math">\(3\)</span> w przypadku, gdy cena
aktywa w tym momencie wynosi <span class="math">\(56.1\)</span>. Tą ostatnią cenę odczytujemy z
poprzedniego wykresu drzewa cen instrumentu bazowego.</p>
<p>Powyższy algorytm wycenia opcję nie tylko w okresie początkowym, ale i
w każdej chwili pośredniej. Jeżeli opcja jest typy europejskiego to
możemy uprościć ten proces. Zauważmy, że w tym przypadku cena zależy
tylko od rozkładu cen w chwili <span class="math">\(t=T\)</span>. Całe drzewo składa się z
niezależnych zmian ceny, o tych samych prawdopodobieństwach <span class="math">\(p\)</span>
i <span class="math">\(1-p\)</span> w każdym rozgałęzieniu. Taki proces zmian jest
stochastycznym procesem Bernouliego. Dla takiego procesu znamy rozkład
końcowy po <span class="math">\(N\)</span> próbach:</p>
<div class="math" id="equation-bernoulli">
<span class="eqno">(2)</span>\[P(k) = {N\choose k} p^k (1-p)^{N-k}.\]</div>
<p>Cena opcji zależy tylko od tego rozkładu końcowego i możemy ją
obliczyć jaka średnią funkcji zmiennej losowej po rozkładzie
<a href="opcje-wycena.html#equation-bernoulli">(2)</a>:</p>
<div class="math" id="equation-srednia_bernoulli">
<span class="eqno">(3)</span>\[\langle S \rangle = \sum_{k=1}^{N} \mathrm{max}(0,S(k)-K) P(k)\]</div>
<p>Implementacja tego wzoru w Sage jest bardzo prosta:</p>
<div class='sage'><script type='text/x-sage'>r=0.1
T = 5/12.
p = 0.5073
K = 50
S0 = 50
u = 1.1224
d = 1/u
N = 5
print exp(-r*T).n()*sum([ binomial(N,j)*p^(j)*(1-p)^(N-j)*max(S0*u^j*d^(N-j)-K,0) for j in range(N+1)])</script></div><p>Wykonując ostatnią komórkę powinniśmy dostać tą samą liczbę jak w
procesie wyceny na całym drzewie.</p>
</div>
<div class="section" id="model-ciagly">
<h2>7.4. Model ciągły<a class="headerlink" href="opcje-wycena.html#model-ciagly" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Obok modeli dyskretnych do opisu ewolucji ceny danego aktywa stosuje
się modele ciągłe. Można by zadać sobie pytanie do czego jest
potrzebne takie podejscie, skoro czas w praktyce jest naturalnie
podzielony na okresy związane z notowaniami np. dziennymy czy miesięcznymi?</p>
<p>Jedną z głównych zalet jest możliwość uzyskania, przynajmniej w
najprostszych przypadkach, analitycznych wyników. Umożliwiają one
np. przeprowadzanie analizy wrażliwości, która była trudna do
przeprowadzenia tylko na podstawie symulacji.</p>
<p>Modele z czasem ciągłym można też rozwiązywać numerycznie stosując
dyskretyzację czasu z pewnym skończonym krokiem. Krok ten decyduje o
dokładności rozwiązania numerycznego, im miejszy krok tym większa
dokładność. Z drugiej strony powoduje to zwiększenie liczby obliczeń,
która w tym przypadku rośnie liniowo z ilością kroków. Jeśli mamy
model ciągły to mamy pełną kontrolę nad wielkością kroku i  ilością
obliczeń i możemy zoptymalizować  procedurę numryczną.</p>
<p>Klasycznym modelem stosowanym do opisu ewolucji ceny aktywów, jest
tzw. <a class="reference external" href="http://el.us.edu.pl/ekonofizyka/index.php/MKZR:Numeryczne_rozwi%C4%85zania_r%C3%B3wna%C5%84_stochastycznch-przyk%C5%82ady">geometryczny ruch Browna:</a>. Dany
jest on przez równanie Langevina:</p>
<div class="math" id="equation-SDE1">
<span class="eqno">(4)</span>\[ dS(t) = \mu S(t) dt + \sigma S(t) d W(t),\]</div>
<p>gdzie <span class="math">\(S\)</span> jest procesem stochastycznym - ceną aktywa. Parametry
<span class="math">\(\mu\)</span> oraz <span class="math">\(\sigma\)</span> mają interpretację stopy wzrostu i
wariancji danego aktywa, odpowiednio. Proces taki jest łatwy do
zasymulowania numerycznego.</p>
<div class="admonition-poeksperymentuj-z-komputerem admonition">
<p class="first admonition-title">Poeksperymentuj z komputerem</p>
<p>Poniższa komórka zawiera kod programu symulującego proces
geometrycznego ruchu Browna. W tablicy <cite>numpy</cite> zapisujemy historię
<cite>M</cite> trajektorii składającą się z <cite>N</cite> punktów czasu. Innymi słowy
<tt class="code docutils literal"><span class="pre">S[3,5]</span></tt> - szóstym krokiem czwartej trajektorii (indeksy
zaczynają sie od zera).</p>
<p>Poeksperymentujmy:</p>
<blockquote class="last">
<div><ul class="simple">
<li>Wykonaj kilka razy komórkę. Za każdym wykonaniem generator
liczb losowych <tt class="code docutils literal"><span class="pre">np.random.randn</span></tt> zwróci inną próbkę liczb
gaussowskich i otrzymamy inne scenariusze symulowanej historii ceny.</li>
<li>Jak wpływa wartość parametru <span class="math">\(r\)</span> oraz <span class="math">\(\sigma\)</span> na wygląd trajektorii?</li>
<li>Zmień liczbę trajektorii na dużo większą. Jak zmienia się czas obliczeń?</li>
<li>Dopisz linijkę obliczającą średnią cenę na końcu symulacji (w
czasie <span class="math">\(t=T\)</span>) <tt class="code docutils literal"><span class="pre">np.average(S[:,-1])</span></tt>.</li>
<li>Wykonaj symulacje kilka razy - zobacz jak zmienia się średnia
dla <span class="math">\(M=10,100,1000,10000\)</span>? Jak wpływa ilość trajektorii na wartość średnią?
Można zautomatyzować ten proces uruchamiając część kodu w dodatkowej pętli.</li>
<li>Wykonaj histogram cen końcowych i porównaj z rozkładem
<span class="math">\(P(S,t=T)\)</span>. W rozdziale <a class="reference external" href="http://el.us.edu.pl/ekonofizyka/index.php/MKZR:Numeryczne_rozwi%C4%85zania_r%C3%B3wna%C5%84_stochastycznch-przyk%C5%82ady">geometryczny ruch Browna</a>
znajduje się zarówno postać wzoru końcowego jak i obliczanie
histogramu, jednak w języku matlab.</li>
</ul>
</div></blockquote>
</div>
<div class='sage'><script type='text/x-sage'>import numpy as np
T,r,sigma = 1,0.1,0.2
S0 = 100
N = 300
M = 10
h = T/N;
S = np.zeros((M,N))
S[:,0] = S0*np.ones(M);

for i in range(1,N):
    S[:,i] = S[:,i-1] + r*S[:,i-1]*h + sigma*np.sqrt(h)*S[:,i-1]*np.random.randn(M)

sum([line(enumerate(S[i,:]),thickness=0.2,figsize=4) for i in range(M)])</script></div><p>Kolejnym elementem analizy jest określenie związku między modelami
ciągłym a drzewami dyskretnymi.</p>
</div>
<div class="section" id="zwiazek-pomiedzy-modelem-ciaglym-i-binarnym">
<h2>7.5. Związek pomiędzy modelem ciągłym i binarnym<a class="headerlink" href="opcje-wycena.html#zwiazek-pomiedzy-modelem-ciaglym-i-binarnym" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p><em>kalibracja modelu binarnego</em></p>
<p>Rozważmy model dwustanowy - jednookresowy. Niech cenę aktywa określa
reguła multiplikatywna.</p>
<div class="math">
\[\begin{split}S_{1} = \left\{
 \begin{array}{l l}
    S_0 u   &amp; \quad \text{z prawdopodobieństwem} \; p\\
    S_0 d   &amp; \quad \text{z prawdopodobieństwem} \; 1-p
 \end{array} \right.\end{split}\]</div>
<p>Mamy więc trzy liczby: <span class="math">\(p,u,d\)</span>, które określają ten
model. Chcemy zastosować go jako przybliżenie pewnego ciągłego procesu
ewolucji ceny, który jest scharakteryzowany przez dwa parametry:</p>
<ul class="simple">
<li><span class="math">\(r t\)</span> - wolna od ryzyka stopa procentowa</li>
<li><span class="math">\(\sigma^2 t=\log(\frac{S_1}{S_0})\)</span> - średniokwadratowe
odchylenie standardowe logarytmicznej stopy zwrotu (w modelu ciągłym).</li>
</ul>
<p>Dla procesu ciągłego opisywanego przez geometryczny proces Wienera:</p>
<div class="math">
\[dS = rSdt+\sigma S dW,\]</div>
<p>prawdopodobieństwo ceny aktywa w czasie <span class="math">\(t\)</span> przy założeniu, że
cena w czasie <span class="math">\(S(t=0)=S_0\)</span> jest dane rozkładem lognormalnym:</p>
<div class="math" id="equation-eq:logn">
<span class="eqno">(5)</span>\[P(S,t|S_0,0)= \frac{1}{\sqrt{2\pi\sigma^2 t S^2}} e^{-\displaystyle\frac{(\log(\frac{S}{S_0})-(r-\frac{1}{2}\sigma^2)t)^2}{2\sigma^2 t}}\]</div>
<p>Wykorzystując wzory na średnią i wariancję (np. z <a class="reference external" href="http://pl.wikipedia.org/wiki/Rozk%C5%82ad_logarytmicznie_normalny">wikipedii</a>)
i porównując z postacią rozkładu <a href="opcje-wycena.html#equation-eq:logn">(5)</a> otrzymujemy wzory na
wartość oczekiwaną i wariancję procesu ciągłego:</p>
<div class="math" id="equation-eq:long_EV">
<span class="eqno">(6)</span>\[\begin{split}E(S) = S_0 e^{r t} \\
Var(S)=   S_0^{2} {\left(e^{\sigma^{2} t} - 1\right)} e^{2 \, r t}\end{split}\]</div>
<p>Chcemy by jeden krok procesu binarnego odtwarzał przynajmniej dwa
pierwsze momenty procesu ciągłego: średnią i wariancję. Tak
więc proces dyskretny będzie musiał spełnić dwa równania:</p>
<div class="math" id="equation-eq:cond">
<span class="eqno">(7)</span>\[\begin{split}E(S) = p S_0 u+(1-p) S_0 d \\
Var(S)=  p (S_0 u)^2+(1-p) (S_0 d)^2 - E(S)\end{split}\]</div>
<p>gdzie podstawiamy wartości średniej i wariancji rozkładu lognormalnego
korzystając z <a href="opcje-wycena.html#equation-eq:long_EV">(6)</a>.</p>
<p>Mamy więc dwa warunki i trzy zmienne do ustalenia, co powoduje, że
potencjalnie może być nieskończenie wiele rozwiązań. Rozważmy pierwszy
przypadek w którym przyjmiemy:</p>
<div class="math" id="equation-eq:crr1">
<span class="eqno">(8)</span>\[d = \frac{1}{u}.\]</div>
<p>Taki wariant drzewa binarnego jest znany jako model Cox-a, Ross-a i
Rubinstein-a (CRR). Rozwiązując układ równań <a href="opcje-wycena.html#equation-eq:crr1">(8)</a>, w
przybliżenie małego czasu <span class="math">\(t\)</span>, otrzymujemy wzory wiążące model ciągły z  drzewem binarnym:</p>
<div class="math" id="equation-eq:crr">
<span class="eqno">(9)</span>\[\begin{split}p &amp;= \frac{e^{rt}-d}{u-d} \\
u &amp;= e^{\sigma \sqrt{t}} \\
d &amp;= e^{-\sigma \sqrt{t}}.\end{split}\]</div>
<p>Wyprowadzenie tych wzorów można łatwo otrzymać na przykład stosując
system algebry komputerowej. I tak, zdefiniujmy najpierw zmienne i
wzory na średnią i wariancję rozkładu lognormalnego oraz zdefiniujmym
układ <a href="opcje-wycena.html#equation-eq:cond">(7)</a>:</p>
<div class='sage'><script type='text/x-sage'>var('r,t,u,d,S0,p,sigma')
lognormE = S0*exp(r*t)
lognormVar = S0^2*exp(2*r*t)*(exp(sigma^2*t)-1)
show([lognormE,lognormVar])

eq1  = lognormE == p*S0*u+(1-p)*S0*d
eq2  = lognormVar ==(p*(S0*u)^2+(1-p)*(S0*d)^2) - lognormE^2

show([eq1,eq2])</script></div><p>Rozwiążmy teraz pierwsze równanie ze względu na <span class="math">\(p\)</span></p>
<div class='sage'><script type='text/x-sage'>psol = solve(eq1,p,solution_dict=True)[0]
p.subs(psol).show()</script></div><p>a następnie podstawmy wynik do drugiego równania i skorzystajmy z
założenia <a href="opcje-wycena.html#equation-eq:crr1">(8)</a>:</p>
<div class='sage'><script type='text/x-sage'>solsu = (eq2).subs(psol).subs(d=1/u).solve(u)
expr = solsu[1].rhs()
expr.show()</script></div><p>Ponieważ interesuje nas granica małych czasów to możemy rozwinąć ten
nieco długi wzór w szereg Taylora w punktcie <span class="math">\(t=0\)</span> i ograniczyć
się do wyrazów pierwszego rzędu w czasie. Zauważmy, że to rozwinięcie
jest identyczne z rozwinięciem drugiego równania ze wzorów
<a href="opcje-wycena.html#equation-eq:crr">(9)</a>, co kończy nasze wyprowadzenie:</p>
<div class='sage'><script type='text/x-sage'>expr.taylor(t,0,1).show()
exp(sigma*sqrt(t)).taylor(t,0,1).show()</script></div><p>Możemy też pokusić się o rozwiązanie układu równań w innej
parametryzacji, w której mamy:</p>
<div class="math" id="equation-eq:JR">
<span class="eqno">(10)</span>\[\begin{split}p &amp;= \frac{1}{2} \\
u &amp;= e^{\sigma \sqrt{t}+(r-\frac{\sigma^2}{2})*t)}\\
d &amp;= e^{-\sigma \sqrt{t}+(r-\frac{\sigma^2}{2})*t)}.\end{split}\]</div>
<p>Taki przypadek jest znany jako parametryzacja
Jarrowa-Rudda. Sprawdźmy, czy rzeczywiście to zachodzi. W równaniach
podstawmy więc od razu <span class="math">\(p = \frac{1}{2}\)</span> i porównajmy
rozwinięcia w szereg wyników oraz rozwinięcia równań <a href="opcje-wycena.html#equation-eq:JR">(10)</a>:</p>
<div class='sage'><script type='text/x-sage'>sols = solve([eq1.subs(p==1/2),eq2.subs(p==1/2)],[u,d])
print "pełne rozwiązanie:"
show(sols[1])
print "Rozwinięcia w t=0:"
sols[1][0].rhs().taylor(t,0,1).show()
sols[1][1].rhs().taylor(t,0,1).show()
print "Rozwinięcia wzorów w  t=0:"
exp(sigma*sqrt(t)+(r-sigma^2/2)*t).taylor(t,0,1).show()
exp(-sigma*sqrt(t)+(r-sigma^2/2)*t).taylor(t,0,1).show()</script></div><p>Ważną uwagą jest to, że model drzewa binarnego i model ciągły jest
równoważny tylko w granicy <span class="math">\(t\to 0.\)</span> Oznacza to, że wyceniając
pewnien instrument jednookresowym modelem dyskretnym otrzymamy spore
różnice w stosunku do modelu ciągłego, jeśli interesująca nas skala
czasowa będzie duża.</p>
<p>Sytuacja jednak się zmienia jeśli zastosujemy model
wielookresowy. Wtedy nasz czas możemy podzielić na wiele odcinków a
liczba tych podziałów będzie zależała od tego jaką dokładność chcemy
osiągnąć. Wycena za pomocą modelu wielokresowego będzie dążyła do
modelu ciągłego w granicy <span class="math">\(n\to \infty.\)</span></p>
<p>Przykład - wyceny opcji z danymi z rynku ciągłego.</p>
<div class='sage'><script type='text/x-sage'>T = 5/12.
N = 123
sigma = 0.4
K = 50
r = 10.0

u = exp(sigma*sqrt(T/N))
d = 1.0/u
p = (exp(r/100*T/N)-d)/(u-d)
C  = exp(r/100*T/N).n()

SP = gen_recombining(N,SP=K,q=u-1.0)

OP = [ [max(0,s-K) for s in SP[N]] ]
for idx in range(N):
    el = [ 1/C*(p*OP[-1][i]+(1-p)*OP[-1][i+1]) for i in range(len(OP[-1])-1)]
    OP.append(el)
print OP[-1]</script></div></div>
<div class="section" id="wzory-blacka-scholesa-dla-europejskiech-opcji-call-i-put">
<h2>7.6. Wzory Blacka Scholesa dla europejskiech opcji Call i Put<a class="headerlink" href="opcje-wycena.html#wzory-blacka-scholesa-dla-europejskiech-opcji-call-i-put" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>W tym rozdziale pozamy własności metody opartej o ciagły proces
losowy. Jest olbrzymią zaletą jest istnienie prostych analitycznych
wzorów na cenę opcji Europejskich, co pozwala na łatwą ich analizę i
poznanie własności.</p>
<p>Model dwumianowy zakładał stacjonarny dwumianowy proces stochastyczny
dla ruchu ceny aktywa (akcji) zachodzący w dyskretnych przedziałach
czasowych. Jeśli przejdziemy do granicy skracając dyskretne okresy
czasowe to ten stochastyczny proces stanie procesem dyfuzji (Ito
proces) zwanym geometrycznym ruchem Browna. Podobnie jak w poprzednim
modelu dwumianowym konstruowany jest portfel wolny od ryzyka
składający się z aktywa i wystawionej opcji call. Taki portfel
generuje bezpieczna stopę zwrotu. Struktura zabezpieczonego portfela
posiada formę zbliżoną do równania dyfuzji ciepła w fizyce.</p>
<p>Wzór Blacka Scholesa na wartość opcji nie wypłacającej dywidendy przyjmuje postać:</p>
<p>Opcja Call</p>
<div class="math">
\[C(S_0,K,r,T,\sigma,r) = S_0 F(d_1) - K e^{-rT} F(d_2)\]</div>
<p>a opcja Put</p>
<div class="math">
\[P(S_0,K,r,T,\sigma,r) = K e^{-rT} F(-d_2) - S_0  F(-d_1)\]</div>
<p>gdzie symbole <span class="math">\(d_1,d_2\)</span> oznaczają:</p>
<div class="math">
\[d_1 = \frac{\ln (S_0/K) + (r+\frac{1}{2} \sigma ^2)T}{\sigma \sqrt{T}}\]</div>
<p>a</p>
<div class="math">
\[d_2 = d_1 - \sigma \sqrt{T}\]</div>
<p>Funkcja <span class="math">\(F(x)\)</span> jest dystrybuantą <a class="reference external" href="http://pl.wikipedia.org/wiki/Rozk%C5%82ad_normalny">rozkładu normalnego</a> o średniej zero i
jednostkowej variancji. Możemy więc wyrazić ją przez funkcja błędu Gaussa:</p>
<div class="math">
\[F(x) =  \frac{1}{2} \, \text{erf}\left(\frac{1}{2} \, \sqrt{2} x\right) + \frac{1}{2}\]</div>
<p>Powyższe wzory możemy wprowadzić do systemu Sage i zbadać ich własności:</p>
<div class="admonition-poeksperymentuj-z-komputerem admonition">
<p class="first admonition-title">Poeksperymentuj z komputerem</p>
<p>Zbadaj własności wzorów na wycenę opcji Call. Zauważmy, że poniższy
wykres jest wykresem ceny opcji a nie wykresem zysk/strata. Linia
niebieska to cena kupna opcji a czerwona to cena jej wykonania.</p>
<ul class="last simple">
<li>Ustaw <span class="math">\(\sigma,r,T\)</span> na zero. Jak można zinterpetować taki profil ceny?</li>
<li>Zwiększ <span class="math">\(\sigma\)</span> - co się dzieje z ceną? Jak zmienia się jej wartość czasowa?</li>
<li>Zostawiąjąc niezmienne (ale dodatnie <span class="math">\(\sigma\)</span>) zwiększ
stopę procentową. Pojawia się dodatkowa linia będąca asymtotą
wzoru Blacka-Scholesa. Co to oznacza?</li>
</ul>
</div>
<div class='sage'><script type='text/x-sage'>var('S')
def longCALL(S,K,P=0):
    return max_symbolic(S-K,0)-P
def longPUT(S,K,P=0):
    return max_symbolic(K-S,0)-P
def shortCALL(S,K,P=0):
    return -max_symbolic(S-K,0)+P
def shortPUT(S,K,P=0):
    return -max_symbolic(K-S,0)+P


var('sigma,S0,K,T,r')
cdf(x) = 1/2*(1+erf(x/sqrt(2)))
d1=(log(S0/K)+(r+sigma**2/2)*T)/(sigma*sqrt(T))
d2=d1-sigma*sqrt(T)
C(S0,K,r,T,sigma) = S0*cdf(d1)-K*exp(-r*T)*cdf(d2)
P(S0,K,r,T,sigma) = K*exp(-r*T)*cdf(-d2)-S0*cdf(-d1)

def plotBS(OPTION=longCALL,K=125,sigma=.1,r=0.0,T=1, c='red'):
    var('S')
    S1,S2 = 100,160

    if "CALL" in OPTION.__name__:
        cena = C
    else:
        cena = P
    if "short" in OPTION.__name__:
        k = -1.0
    else:
        k = 1.0


    p  = plot( OPTION(S,K),(S,S1,S2),color=c,thickness=2.5)
    p += plot( OPTION(S,exp(-r*T)*K),(S,S1,S2),color='gray',thickness=.5)
    p += plot(k*(cena(x,K,r,T,sigma)),(x,S1,S2),color='blue',thickness=1)
    p += point([(K,0)],color='brown',size=40,gridlines=[[K],[]])
    p += text(r"$K$",(K,2))

    return p

@interact
def _(s=slider(0.001,0.5,0.02,label='volatility',default=0.1),r=slider(0,0.1,0.01),T=slider(1,12,1),K=slider(104,150,1,default=129)):

    p = plotBS(OPTION=longCALL,K=K, c='red',sigma=s,r=r,T=T)
    p.set_axes_range(ymax=50,ymin=0)
    p.show(figsize=6)</script></div><p>Opcję europejską możemy wycenić zarówno korzystając z analitycznego
wzoru jak i bezpośrednio z symulacji procesu losowego. W tym celu
generujemy <span class="math">\(M\)</span> trajektorii ceny instrumentu podstawowego i
obliczamy średnią z funkcji wyceny opcji w ostatnim momencie czasu.</p>
<div class='sage'><script type='text/x-sage'>var('sigma,S0,K,T,r')
cdf(x) = 1/2*(1+erf(x/sqrt(2)))
d1=(log(S0/K)+(r+sigma**2/2)*T)/(sigma*sqrt(T))
d2=d1-sigma*sqrt(T)
C(S0,K,r,T,sigma) = S0*cdf(d1)-K*exp(-r*T)*cdf(d2)


K = 125.0

r,T,sigma = 0.1, 1, 0.1
S0 = 120
print "Wycena ze wzoru:",C(S0,K,r,T,sigma).n()

import numpy as np
N=100
M=1000
h=T/N;
S=np.zeros((M,N))
S[:,0]=S0*np.ones(M);
for i in range(1,N):
  S[:,i]=S[:,i-1] + r*S[:,i-1]*h + sigma*np.sqrt(h)*S[:,i-1]*np.random.randn(M)

call_MC=np.exp(-r*T)*np.mean( np.maximum(S[:,N-1]-K,0) )
put_MC=np.exp(-r*T)*np.mean( np.maximum(K-S[:,N-1],0) )
print "Wycena z symuacji Monte-Carlo:",call_MC,put_MC

sum([line(enumerate(S[i,:]),thickness=0.2,figsize=4) for i in range(123)])</script></div></div>
<div class="section" id="porownanie-wyceny-modelem-binarnym-i-bs">
<h2>7.7. Porównanie wyceny modelem binarnym i BS<a class="headerlink" href="opcje-wycena.html#porownanie-wyceny-modelem-binarnym-i-bs" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Załóżmy, że wyceniamy opcję Europejską.  Można zadać sobie pytanie o
ile będą różniły się wyceny według modelu ciągłego i binarnego z
<span class="math">\(N\)</span> okresami. W tym celu definiujemy sobie funkcje wyceniające
opcje modelem binarnym <tt class="code docutils literal"><span class="pre">Bin_Call</span></tt>. Można narysować wykres ceny
opcji od ilości pokoleń drzewa. Cena wynikającą ze wzoru
Blacka-Scholesa będzie zaznaczoną przerywaną poziomą linią.</p>
<div class="admonition-poeksperymentuj-z-komputerem admonition">
<p class="first admonition-title">Poeksperymentuj z komputerem</p>
<p>Poniższy kod zawiera zaimlementowaną funkcję wyceny opcji
europejskie kupna oraz rysuje wykres jej wyceny w zależności od
ilości okresów.</p>
<ul class="last simple">
<li>Jaki jest błąd względny dla małej liczby okresów: <span class="math">\(N=1,2,3\)</span>?</li>
<li>Zaimplementuj podobne porównanie dla opcji sprzedaży.</li>
<li>Czy dla dużych <span class="math">\(N\)</span> cena opcji zależy od metody jej wyceniania?</li>
</ul>
</div>
<div class='sage'><script type='text/x-sage'>def Bin_Call(N,S0,K,r,T,sigma):
    u = exp(sigma*sqrt(T/N))
    d = 1.0/u
    p = (exp(r*T/N)-d)/(u-d)
    return exp(-r*T).n()*sum([binomial(N,j)*p^j*(1-p)^(N-j)*max(S0*u^j*d^(N-j)-K,0) for j in range(N+1)])

sigma,S0,K,T,r=0.1,120,125,1,0.1

point( [(i,Bin_Call(i,S0,K,r,T,sigma)) for i in range(1,36,1)], \
  gridlines=[None,[C(S0,K,r,T,sigma).n()]],figsize=(8,2)).show()</script></div></div>
<div class="section" id="analiza-wrazliwosci">
<span id="greeks"></span><h2>7.8. Analiza wrażliwości<a class="headerlink" href="opcje-wycena.html#analiza-wrazliwosci" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<dl class="docutils">
<dt>Analiza wrażliwości określa  jak czuła jest cena opcji na zmianę</dt>
<dd>wartości wielkości rynkowych.</dd>
</dl>
<p>Wiemy, że na cenę opcji w chwili <span class="math">\(t=0\)</span> wpływają następujące
wielkości:</p>
<blockquote>
<div><ul class="simple">
<li>cena aktywa podstawowego: <span class="math">\(S\)</span> (w chwili <span class="math">\(t=0\)</span>),</li>
<li>cena wykonania: <span class="math">\(K\)</span>,</li>
<li>czas do wygaśnięcia: <span class="math">\(T\)</span>,</li>
<li>stopa procentowa wolna od ryzyka: <span class="math">\(r\)</span>,</li>
<li>zmienność ceny aktywa (<em>volatility</em>) <span class="math">\(\sigma\)</span></li>
</ul>
</div></blockquote>
<p>Powstaje pytanie jak cena opcji jest czuła na zmiany tych parametrów ?</p>
<p>Aby odpowiedzieć na to pytanie możemy posłużyć się, może nie
eleganckim ale usprawiedliwionym i skutecznym do tego celu,
rozwinięciem tej funkcji we szereg Taylora i uwzględnić w nim tylko
pierwsze pochodne cząstkowe (z wyjątkowo drugą pochodną względem
ceny opcji względem ceny aktywa).</p>
<p>W ten sposób określoną zmianę ceny przybliżamy otrzymanym wzorem
zakładając ze zmiana nie jest mniejsza niż.</p>
<p>Pochodne cząstkowe ceny opcji wchodzące w sklad tego przybliżenia maja
znaczenie praktyczne bedac używane i oznaczane swymi nazwami.</p>
<p>Oznaczmy symbolem <span class="math">\(V\)</span> cenę naszej opcji. W przypadku
europejskiej opcji Put lub Call będziemy stosować symbole od
pierwszych liter, odpowiednio: <span class="math">\(P\)</span> <span class="math">\(C\)</span>. Tak więc dla
dowolnej opcji zawsze możemy zapisać:</p>
<div class="math">
\[\Delta V \simeq \frac{\partial V}{\partial T} \Delta T + \frac{\partial V}{\partial S} \Delta S + \frac{1}{2} \frac{\partial ^2 V}{\partial S^2}(\Delta S)^2 + \frac{\partial V}{\partial \sigma} \Delta \sigma + \frac{\partial V}{\partial r} \Delta r .\]</div>
<p>Współczynniki w powyższym wzorze można ławto obliczyć jeśli dany jest
formuła  analityczna na cenę opcji. Najczęsciej spotykanym przypadkiem są
wzory  Blacka-Scholesa dla europejskich opcji kupna i
sprzedaży.</p>
<div class="admonition-dla-dociekliwych admonition">
<p class="first admonition-title">Dla dociekliwych</p>
<p class="last">Spróbuj obliczyć poniższe współczynniki dla modelu CRR. Czy można
policzyć jeśli jedyną metodą wyceny jest metoda Monte Carlo.</p>
</div>
<div class="section" id="delta-opcji">
<h3>7.8.1. Delta opcji<a class="headerlink" href="opcje-wycena.html#delta-opcji" title="Stały odnośnik do tego nagłówka">¶</a></h3>
<p>Zmiana ceny opcji przy zmianie ceny aktywa podstawowego nosi nazwę
współczynnika delta.</p>
<div class="math">
\[\Delta = \frac{\partial V}{ \partial S}\]</div>
<p>dla europejskiej opcji Call wycenionej według modelu Blacka-Scholesa
(bez dywidendy) wynosi ona:</p>
<div class="math">
\[\Delta_{Call} = N(d_1)\]</div>
<p>a dla opcji Put</p>
<div class="math">
\[\Delta_{Put} = N(d_1) - 1\]</div>
<p>Powyższe wzory możemy otrzymać przez różniczkowanie wzorów
Blacka-Scholesa ze względu na <span class="math">\(S_0\)</span>. Sprawdźmy z pomocą systemu
algebry komputerowej czy, rzeczywiście są spełnione.</p>
<p>Po pierwsze wczytajmy sobie wzory Blacka-Scholesa:</p>
<div class='sage'><script type='text/x-sage'>var('sigma,S0,K,T,r')
cdf(x) = 1/2*(1+erf(x/sqrt(2)))
d1=(log(S0/K)+(r+sigma**2/2)*T)/(sigma*sqrt(T))
d2=d1-sigma*sqrt(T)
C(sigma,S0,K,T,r) = S0*cdf(d1)-K*exp(-r*T)*cdf(d2)
P(sigma,S0,K,T,r) = K*exp(-r*T)*cdf(-d2)-S0*cdf(-d1)</script></div><div class='sage'><script type='text/x-sage'>try:
    print bool( C.diff(S0) == cdf(d1) )
    print bool( P.diff(S0) == cdf(d1)-1 )
    print bool( C.diff(S0) - P.diff(S0) == 1 )
except:
    print "Wczytaj wzory Blacka-Scholesa!"</script></div><p>Widać, że zachodzi własność:</p>
<div class="math">
\[\Delta_{call} - \Delta_{put} = 1,\]</div>
<p>która jest bezpośrednią konsekwencja parytetu kupna sprzedaży.</p>
<p>Delta wskazuje na ilość akcji potrzebnych do otworzenia zwrotu z
opcji.</p>
<p>Np., <span class="math">\(\Delta_{call} = 0.80\)</span> znaczy ze działa jak 0.80
akcji. Jeśli cena akcji wzrośnie o 1, cena opcji call wzrośnie o 0.80.
cecha ta pozwala na budowanie strategii zabezpieczających. Ale o
zastosowania analizy wrażliwości w strategii zabezpieczania przed
ryzykiem można znaleźć w <strong>Hedging za pomoca opcji</strong>.</p>
<p>Narysujmy jak zależy dla pewnej opcji Call Delta od ceny instrumentu
bazowego:</p>
<div class='sage'><script type='text/x-sage'>try:
    p = plot( C.diff(S0)(0.1,S0,120,1,0.03),(S0,90,150),figsize=5)
    p += plot( C(0.1,S0,120,1,0.03)/10,(S0,90,150),color='gray')
    p.show()
except:
    print "Wczytaj wzory Blacka-Scholesa!"</script></div></div>
<div class="section" id="wspolczynnik-gamma">
<h3>7.8.2. Współczynnik gamma<a class="headerlink" href="opcje-wycena.html#wspolczynnik-gamma" title="Stały odnośnik do tego nagłówka">¶</a></h3>
<dl class="docutils">
<dt><em>Gamma</em> drugą pochodną ceny opcji względem ceny akcji. Gamma jest</dt>
<dd>pierwsza pochodną delta w stosunku do ceny aktywa. Gamma jest także
nazywana <em>krzywizną</em>.</dd>
</dl>
<div class="math">
\[\Gamma_c = \frac{\partial ^2 C}{\partial S^2} = \frac{\Delta_c}{\partial S}\]\[\Gamma_p = \frac{\partial ^2 P}{\partial S^2} = \frac{\Delta_p}{\partial S}\]</div>
<p>Współczynnik gamma jest zatem miarą niestabilności współczynnika delta.</p>
<div class='sage'><script type='text/x-sage'>try:
    p = plot( C.diff(S0,2)(0.1,S0,120,1,0.03),(S0,90,150),figsize=5)
    p += plot( C.diff(S0)(0.1,S0,120,1,0.03)/10,(S0,90,150),color='gray')
    p += plot( C(0.1,S0,120,1,0.03)/100,(S0,90,150),color='gray')
    p.show()
except:
    print "Wczytaj wzory Blacka-Scholesa!"</script></div><p>Interpretacja</p>
<p>Jeżeli w wyniku zmiany kursu instrumentu bazowego współczynnik delta
zmieni się z 0.5 do 0.52 to wówczas zmiana delty o 0.02 określać
będzie wartość współczynnika gamma.</p>
<div class="admonition-przyklad admonition">
<p class="first admonition-title">Przykład.</p>
<p>Niech aktualna wartość instrumentu bazowego wynosi =75 jednostek
pieniężnych. Aktualna wartość opcji = 0.35. Delta opcji = 0.16 a
gamma opcji = 0.05.  Jaka jest wartość opcji jeżeli kurs
instrumentu bazowego wzrośnie do 80?</p>
<p>A wiec zmiana ceny
instrumentu bazowego = 5 a zmiana ceny wynikająca ze wsp. delta = 5
x 0.16 = 0.80. Wzrost wartości instrumentu bazowego o 5 powoduje
wzrost wartości delty a zatem należy wyznaczyć dodatkową zmianę
wartości opcji wynikającą z gamma. Zmiana ceny wynikająca z gamma =
0.5 x 0.05 x 52 = 0.62.</p>
<p class="last">Nowa wartość opcji to stara wartość + zmiana z delty + zmiany gamma
czyli: 0.35 + 0.80 + 0.62 = 1.77</p>
</div>
</div>
<div class="section" id="wspolczynnik-theta">
<h3>7.8.3. Współczynnik Theta<a class="headerlink" href="opcje-wycena.html#wspolczynnik-theta" title="Stały odnośnik do tego nagłówka">¶</a></h3>
<p>Kolejna pochodna cząstkowa jest wielkość zwana Theta.</p>
<p>Określa ona jak się zachowa cena opcji call (put) jeśli zmieni się
czas do wygaśnięcia, a wszystko inne zostanie stałe?</p>
<p>Theta jest to pierwsza pochodna ceny względem czasu.</p>
<p>Opcje to „psujące się” aktywa, ponieważ wartość ich zanika po pewnym
(wygaśnięcie).</p>
<p>Wartość opcji = wartość wewnętrzna + premia czasowa.</p>
<p>Wielkość tę dla opcja call i put wylicza się:</p>
<div class="math">
\[\Theta_c = \frac{\partial C}{\partial t}\]\[\Theta_p = \frac{\partial P}{\partial t}\]</div>
<p>Theta większa od zera gdyż im więcej  jest czasu do wygaśnięcia tym większa wartość opcji.</p>
<p>Ale ponieważ czas do wygaśnięcia może tylko maleć theta jest
rozpatrywana jako wartość ujemna.  Biorąc pod uwagę możliwość
zajmowanej pozycji w opcjach należy pamiętać, że:</p>
<ul class="simple">
<li>Upływ czasu szkodzi posiadaczowi opcji.</li>
<li>Upływ czasu działa na korzyść temu co opcje wystawił.</li>
</ul>
<p>Ze wzoru Blacka Scholes można wyliczyć wartość:</p>
<div class="math">
\[\Theta_c = - \frac{S \sigma e^{-.5(d_1 ^2)}}{2\sqrt{2\pi t}} -rKe^{-rt}N(d_2)\]\[\Theta_p = \frac{S \sigma e^{-.5(d_1 ^2)}}{2\sqrt{2 \pi t}} +rKe^{-rt} N(d_2)\]</div>
<div class='sage'><script type='text/x-sage'>try:
    p = plot( C.diff(T)(0.1,S0,120,1,0.03),(S0,90,150),figsize=5)
    p += plot( C(0.1,S0,120,1,0.03)/10,(S0,90,150),color='gray')
    p.show()
except:
    print "Wczytaj wzory Blacka-Scholesa!"</script></div><p>Liczenie  Theta - interpretacja</p>
<p>Równania określają theta na rok. Np.  <span class="math">\(\Theta = -5.58\)</span>, znaczy,
że opcja straci 5.58 w wartości ceny na rok - czyli (0.02 na dzień).</p>
<p>Theta pozycji krótkich jest dodatnia. Theta pozycji długich jest
ujemna. Opcje at-the-money mają największe wartości theta.</p>
<p>Tabela poniżej  pokazuje znaki  pochodnych cząstkowych dla róznych pozycji opcji.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">.</th>
<th class="head">Delta</th>
<th class="head">Theta</th>
<th class="head">Gamma</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Long call</td>
<td>+</td>
<td>-</td>
<td>+</td>
</tr>
<tr class="row-odd"><td>Long put</td>
<td>-</td>
<td>-</td>
<td>+</td>
</tr>
<tr class="row-even"><td>Short call</td>
<td>-</td>
<td>+</td>
<td>-</td>
</tr>
<tr class="row-odd"><td>Short put</td>
<td>+</td>
<td>+</td>
<td>-</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Znak gamma jest zawsze przeciwny do znaku theta</p>
</div>
<div class="section" id="czulosc-wzgledem-odchylenia-standardowego-vega">
<h3>7.8.4. Czułość względem odchylenia standardowego - Vega<a class="headerlink" href="opcje-wycena.html#czulosc-wzgledem-odchylenia-standardowego-vega" title="Stały odnośnik do tego nagłówka">¶</a></h3>
<p>Odpowiada na pytanie, jak się zmieni wartość opcji Call (Put) jeśli
zmieni się odchylenie standardowe zwrotu czyli czułość na zmienność
(volatility) funkcji?</p>
<dl class="docutils">
<dt><em>Vega</em> pierwszą cząstkową pochodną ceny opcji względem zmienności</dt>
<dd>(volatility) aktywa podstawowego.</dd>
</dl>
<div class="math">
\[\text{vega}_c = \frac{\partial C}{\partial \sigma}\]\[\text{vega}_c = \frac{\partial P}{\partial \sigma}\]</div>
<p>Im wyższa volatility tym większa wartość opcji.  Np., opcja o vega
0.30 zyskuje 0.30% wartości na każdy punkt procentowy wzrostu
spodziewanej zmienności aktywa.  Vega bywa także nazywane kappa,
omega, tau, zeta, lub sigma prim.  Ze wzoru Blacka Scholesa można
przykładowo wyliczyć wartości Vega.</p>
<div class="math">
\[\text{vega} = \frac{S\sqrt{t}e^{-0.5(d_1 ^2)}}{\sqrt{2\pi}}\]</div>
<p>Vega pozycji długich jest dodatnia. Vega pozycji krótkich jest ujemna.
Wartości opcji są <strong>bardzo</strong> czułe na zmianę odchylenia standardowego
ceny aktywa.  Im większe volatility, tym więcej są warte opcje call i
put.  Opcje at-the-money mają największą wartość Vega. Vega maleje dla
opcji in- oraz out-of-the-money. <strong>Vega</strong>, maleje wraz z upływem czasu
do terminu wygaśnięcia.</p>
<div class='sage'><script type='text/x-sage'>var('sigma,S0,K,T,r')
cdf(x) = 1/2*(1+erf(x/sqrt(2)))
d1=(log(S0/K)+(r+sigma**2/2)*T)/(sigma*sqrt(T))
d2=d1-sigma*sqrt(T)
C(sigma,S0,K,T,r) = S0*cdf(d1)-K*exp(-r*T)*cdf(d2)
plot( C.diff(sigma,1)(.1,S0,125,1,.1),(S0,70,150),figsize=5)</script></div></div>
<div class="section" id="rho">
<h3>7.8.5. Rho<a class="headerlink" href="opcje-wycena.html#rho" title="Stały odnośnik do tego nagłówka">¶</a></h3>
<p><em>Rho</em> pierwsza pochodna ceny opcji względem stopy procentowej wolnej od ryzyka:</p>
<div class="math">
\[\rho _c = Kte^{-rt}N(d_2)\]\[\rho _p = -Kte^{-rt}N(-d_2)\]</div>
<p>Rho jest najmniej znaczącą z pochodnych. Nawet jeśli opcja ma
wyjątkowo długie życie, zmiany stopy procentowej wpływają na premie
niewiele.</p>
<div class='sage'><script type='text/x-sage'>try:
    p = plot( C.diff(r)(0.1,S0,120,1,0.03),(S0,90,150),figsize=5)
    p += plot( C(0.1,S0,120,1,0.03)/10,(S0,90,150),color='gray')
    p.show()
except:
    print "Wczytaj wzory Blacka-Scholesa!"</script></div></div>
</div>
<div class="section" id="wycena-opcji-amerykanskiej-modelami-binarnymi-i-ciaglym">
<h2>7.9. Wycena opcji Amerykańskiej modelami binarnymi i ciągłym<a class="headerlink" href="opcje-wycena.html#wycena-opcji-amerykanskiej-modelami-binarnymi-i-ciaglym" title="Stały odnośnik do tego nagłówka">¶</a></h2>
<p>Nie zawsze wycena opcji jest możliwa poprzez uśrednianie po rozkładzie
brzegowym dla <span class="math">\(t=T\)</span>. Przykładem są opcje amerykańskie. Różnią się
one od europejskich tym, że prawo do zawarcia transakcji obowiązuje
nie tylko w chwili <span class="math">\(t=T\)</span>, ale w dowolnej chwili przed
nią. Posiadacz tego prawa musi zadecydować kiedy będzie chciał z tego
prawa skorzystać.</p>
<p>Procedura wyceny takiej opcji, będzie korzystała z pełnej informacji o
historii zmian ceny instrumentu. Innymi słowy, w języku trajektorii
oznacza to, że będziemy obliczać maximum po całej trajektorii a nie
tylko po wartości końcowej.</p>
<p>Algorytm wyznaczania ceny opcji korzysta z warunku braku
arbitrażu. Postępujemy podobnie jak przy wycenie opcji europejskiej na
całym drzewie. Jednak w każdym rozwidleniu drzewa, sprawdzamy czy
wartość otrzymana z warunku braku arbitrażu <a href="opcje-wycena.html#equation-eq:Parb">(1)</a> nie jest
mniejsza od wartości wewnętrzej opcji. Jesli tak jest to wpisujemy
właśnie tą wartość wewnętrzą do drzewa, zamiast wartości wynikającej z
<a href="opcje-wycena.html#equation-eq:Parb">(1)</a>. Poniżej prezentujemy możliwą implementację tego
algorytmu:</p>
<div class='sage'><script type='text/x-sage'>T = 5/12.
N = 8
sigma = 0.4
K = 50
r = 0.26

u = exp(sigma*sqrt(T/N))
d = 1.0/u
p = (exp(r*T/N)-d)/(u-d)
C  = exp(r*T/N).n()

S0 = K-15
SP = gen_recombining(N,SP=S0,q=u-1.0)

# PUT AM
OP = [ [max(0,K-s) for s in SP[N]] ]
for j in range(N):
    el = [ max( max(K-SP[N-j-1][i],0) , 1/C*(p*OP[-1][i]+(1-p)*OP[-1][i+1])) for i in range(len(OP[-1])-1)]
    OP.append(el)
OP.reverse()

def Bin_Put(N,sigma,S0,K,T,r):
    u = exp(sigma*sqrt(T/N))
    d = 1.0/u
    p = (exp(r*T/N)-d)/(u-d)
    return exp(-r*T).n()*sum([binomial(N,j)*p^j*(1-p)^(N-j)*max(K-S0*u^j*d^(N-j),0) for j in range(N+1)])

print "Opcja amerykańska:",OP[0],"Opcja europejska:",Bin_Put(N,sigma,S0,K,T,r)</script></div><p>Widzimy, że wartość opcji amerykańskiej przy podanych parametrach
różni się znacznie od opcji europejskiej. Mozna się przypatrzeć na drzewie w których miejscach wartość wewnętrzna będzie większa od wartości arbitrażowej. Zobaczmy:</p>
<div class='sage'><script type='text/x-sage'>html.table( [[max(l-K,0)>l2 for l,l2 in zip(b,b2)] for b,b2 in zip(SP,OP)] )</script></div><div class="admonition-poeksperymentuj-z-komputerem admonition">
<p class="first admonition-title">Poeksperymentuj z komputerem</p>
<ul class="last simple">
<li>W powyższym kodzie pozmieniaj wartość początkową aktywa. Jak
zmienia się cena opcji? Jak zmienia się tabla z ostatniej komórki
Sage?</li>
<li>Zaimplementuj wycenę amerykańskiej opcji Call. Porównaj wartość z
opcją europejska. Czy zaobserwowałeś coś dziwnego?</li>
<li>Zaimplementuj wycenę opcji amerykańskiej w oparciu o model ciągły
stosując odpowiednie uśrednianie po trajektoriach.</li>
</ul>
</div>
<blockquote>
<div><div class='sage'><script type='text/x-sage'>T = 5/12.
N = 8
sigma = 0.4
K = 50
r = 0.26

u = exp(sigma*sqrt(T/N))
d = 1.0/u
p = (exp(r*T/N)-d)/(u-d)
C  = exp(r*T/N).n()

S0 = K-15
SP = gen_recombining(N,SP=S0,q=u-1.0)

#call AM
OP = [ [max(0,s-K) for s in SP[N]] ]
for j in range(N):
    el = [ max( max(SP[N-j-1][i]-K,0) , 1/C*(p*OP[-1][i]+(1-p)*OP[-1][i+1])) for i in range(len(OP[-1])-1)]
    OP.append(el)
OP.reverse()

def Bin_Call(N,sigma,S0,K,T,r):
    u = exp(sigma*sqrt(T/N))
    d = 1.0/u
    p = (exp(r*T/N)-d)/(u-d)
    return exp(-r*T).n()*sum([binomial(N,j)*p^j*(1-p)^(N-j)*max(S0*u^j*d^(N-j)-K,0) for j in range(N+1)])


html.table( [[max(l-K,0)>l2 for l,l2 in zip(b,b2)] for b,b2 in zip(SP,OP)] )</script></div><div class='sage'><script type='text/x-sage'>import numpy as np
N = 300
M = 1000
h = T/N;
r = 0.1
S = np.zeros((M,N))

S[:,0] = S0*np.ones(M);
for i in range(1,N):
  S[:,i] = S[:,i-1] + r*S[:,i-1]*h + sigma*np.sqrt(h)*S[:,i-1]*np.random.randn(M)</script></div></div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <div class="sphinxlocaltoc">
  <h3><a href="http://visual.icse.us.edu.pl/ARF/index.html">Spis treści</a></h3>
  <ul>
<li><a class="reference internal" href="opcje-wycena.html#">7. Metody wyznaczania ceny opcji</a><ul>
<li><a class="reference internal" href="opcje-wycena.html#jak-wyznaczyc-cene-opcji">7.1. Jak wyznaczyć cenę opcji?</a></li>
<li><a class="reference internal" href="opcje-wycena.html#model-minimalny-rynek-dwustanowy-jednookresowy">7.2. Model minimalny - rynek dwustanowy jednookresowy</a></li>
<li><a class="reference internal" href="opcje-wycena.html#wycena-opcji-na-drzewie-binarnym">7.3. Wycena opcji na drzewie binarnym</a></li>
<li><a class="reference internal" href="opcje-wycena.html#model-ciagly">7.4. Model ciągły</a></li>
<li><a class="reference internal" href="opcje-wycena.html#zwiazek-pomiedzy-modelem-ciaglym-i-binarnym">7.5. Związek pomiędzy modelem ciągłym i binarnym</a></li>
<li><a class="reference internal" href="opcje-wycena.html#wzory-blacka-scholesa-dla-europejskiech-opcji-call-i-put">7.6. Wzory Blacka Scholesa dla europejskiech opcji Call i Put</a></li>
<li><a class="reference internal" href="opcje-wycena.html#porownanie-wyceny-modelem-binarnym-i-bs">7.7. Porównanie wyceny modelem binarnym i BS</a></li>
<li><a class="reference internal" href="opcje-wycena.html#analiza-wrazliwosci">7.8. Analiza wrażliwości</a><ul>
<li><a class="reference internal" href="opcje-wycena.html#delta-opcji">7.8.1. Delta opcji</a></li>
<li><a class="reference internal" href="opcje-wycena.html#wspolczynnik-gamma">7.8.2. Współczynnik gamma</a></li>
<li><a class="reference internal" href="opcje-wycena.html#wspolczynnik-theta">7.8.3. Współczynnik Theta</a></li>
<li><a class="reference internal" href="opcje-wycena.html#czulosc-wzgledem-odchylenia-standardowego-vega">7.8.4. Czułość względem odchylenia standardowego - Vega</a></li>
<li><a class="reference internal" href="opcje-wycena.html#rho">7.8.5. Rho</a></li>
</ul>
</li>
<li><a class="reference internal" href="opcje-wycena.html#wycena-opcji-amerykanskiej-modelami-binarnymi-i-ciaglym">7.9. Wycena opcji Amerykańskiej modelami binarnymi i ciągłym</a></li>
</ul>
</li>
</ul>

  </div>
  <h4>Poprzedni temat</h4>
  <p class="topless"><a href="http://visual.icse.us.edu.pl/ARF/opcje.html"
                        title="poprzedni rozdział">6. Opcje</a></p>
  <h4>Następny temat</h4>
  <p class="topless"><a href="http://visual.icse.us.edu.pl/ARF/Instrumenty_syntetyczne.html"
                        title="następny rozdział">8. Instrumenty syntetyczne</a></p>
  <h3>Ta strona</h3>
  <ul class="this-page-menu">
    <li><a href="http://visual.icse.us.edu.pl/ARF/_sources/opcje-wycena.txt"
           rel="nofollow">Pokaż źródło</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Szybkie wyszukiwanie</h3>
    <form class="search" action="http://visual.icse.us.edu.pl/ARF/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Szukaj" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Wprowadź szukany termin lub nazwę modułu, klasy lub funkcji.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  </div>
  <div class="relbar-bottom">
    
    <div class="related">
      <h3>Nawigacja</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http://visual.icse.us.edu.pl/ARF/genindex.html" title="Indeks ogólny"
             >indeks</a></li>
        <li class="right" >
          <a href="http://visual.icse.us.edu.pl/ARF/Instrumenty_syntetyczne.html" title="8. Instrumenty syntetyczne"
             >dalej</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="http://visual.icse.us.edu.pl/ARF/opcje.html" title="6. Opcje"
             >wstecz</a> &nbsp; &nbsp;</li>
  <li><a href="http://visual.icse.us.edu.pl/ARF/index.html">Analiza Rynków Finansowych</a> &raquo;</li>
   
      </ul>
    </div>
  </div>
  
  <div class="footer">
    <a class="logo" href="http://upgow.us.edu.pl/" target="_blank"><img src="_static/upgow.png" alt="UPGOW"/></a><br/>
    <img src="_static/stopka_EU.png" alt="EU"/><br/>
    &copy; Copyright 2013, ML and MK.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.
  </div>
  </body>
</html>